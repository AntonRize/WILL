---
layout: default
title: Orbital Mechanics
---

<div id="will-engine-container" class="relative w-full h-[90vh] bg-black text-gray-300 font-mono text-xs overflow-hidden flex flex-col border border-gray-800 rounded-lg shadow-2xl">

    <div class="bg-gray-950 p-3 border-b border-gray-800 flex justify-between items-center shrink-0 z-20">
        <div class="flex items-center gap-3">
            <div class="w-3 h-3 rounded-full bg-blue-500 shadow-[0_0_10px_rgba(59,130,246,0.8)] animate-pulse"></div>
            <h1 class="text-lg font-bold tracking-widest text-gray-100">
                WILL <span class="text-blue-500 font-light">Relational Geometry</span>
            </h1>
        </div>
        <div class="flex items-center gap-4">
             <div class="hidden sm:block text-[10px] text-gray-500 uppercase tracking-widest">
                \( \text{SPACETIME} \equiv \text{ENERGY} \)
            </div>
            <div class="flex bg-gray-900 rounded p-1 border border-gray-800">
                <button id="btn-mode-verify" class="px-3 py-1 rounded text-[10px] font-bold transition-all bg-blue-900/30 text-blue-400 border border-blue-800">
                    PATH 1: VERIFY
                </button>
                <button id="btn-mode-reconstruct" class="px-3 py-1 rounded text-[10px] font-bold transition-all text-gray-500 hover:text-gray-300">
                    PATH 2: RECONSTRUCT
                </button>
            </div>
        </div>
    </div>

    <div class="flex flex-1 overflow-hidden relative">
        
        <div class="w-80 bg-gray-900/90 backdrop-blur border-r border-gray-800 p-5 overflow-y-auto z-10 flex flex-col gap-6">
            
            <div id="controls-area" class="space-y-6">
                </div>

            <div class="space-y-1">
                <div class="flex justify-between text-[9px] text-gray-500 uppercase">
                    <span>Closure Stability (\(\delta\))</span>
                    <span id="val-delta" class="font-mono text-gray-300">0.910</span>
                </div>
                <div class="w-full h-1 bg-gray-800 rounded-full overflow-hidden">
                     <div id="bar-delta" class="h-full bg-green-500 transition-all duration-300" style="width: 90%"></div>
                </div>
            </div>

             <div class="mt-auto border-t border-gray-800 pt-4 space-y-3">
                <div class="flex justify-between text-[10px] text-gray-500 uppercase font-bold">
                    <span>Phase \(\theta\)</span>
                    <span id="val-phase" class="text-blue-300">0.00 rad</span>
                </div>
                <input type="range" id="input-phase" min="0" max="6.283" step="0.01" value="0" class="w-full h-1 bg-gray-700 rounded appearance-none accent-blue-500">
                
                <button id="btn-play" class="w-full py-2 rounded flex justify-center items-center gap-2 font-bold transition-all text-[10px] uppercase tracking-wider bg-blue-900/30 text-blue-400 border border-blue-900 hover:bg-blue-900/50">
                    START SIMULATION
                </button>
            </div>
        </div>

        <div class="flex-1 bg-[#050505] relative flex items-center justify-center overflow-hidden cursor-crosshair" id="canvas-container">
            <canvas id="orbit-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            
            <div class="absolute top-4 left-4 pointer-events-none">
                 <div class="bg-gray-900/80 backdrop-blur border border-gray-700 p-3 rounded shadow-xl">
                    <div class="flex gap-4 font-mono text-xs">
                        <div class="text-blue-400 flex flex-col">
                            <span class="text-[9px] text-gray-500 uppercase">Potential \(\kappa\)</span>
                            <span id="hud-kappa">0.000</span>
                        </div>
                        <div class="w-px bg-gray-700"></div>
                        <div class="text-red-400 flex flex-col">
                            <span class="text-[9px] text-gray-500 uppercase">Kinematics \(\beta\)</span>
                            <span id="hud-beta">0.000</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="w-72 bg-gray-900/90 backdrop-blur border-l border-gray-800 p-5 overflow-y-auto z-10 flex flex-col gap-4">
            <div class="text-[9px] font-bold text-gray-500 uppercase tracking-wider mb-2">Fundamental Invariants</div>

            <div class="bg-gray-950 border border-green-900/30 p-4 rounded relative overflow-hidden group">
                <div class="absolute left-0 top-0 bottom-0 w-1 bg-green-500 shadow-[0_0_10px_#22c55e]"></div>
                <div class="flex justify-between items-center mb-1">
                    <span class="text-xs text-gray-400 font-bold">WILL Invariant</span>
                    <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                </div>
                <div id="val-invariant" class="text-3xl font-bold text-green-400 font-mono tracking-tighter">1.00000</div>
                <div class="text-[9px] text-gray-500 mt-2 font-mono border-t border-gray-800 pt-2">
                    \( \frac{E \cdot T}{M \cdot L} \equiv 1 \)
                </div>
            </div>

            <div class="bg-gray-950 border border-gray-800 p-3 rounded">
                <div class="text-[10px] text-gray-500 uppercase mb-1">Relativistic Precession</div>
                <div id="val-precession" class="text-yellow-500 text-lg font-mono font-bold">0.00</div>
                <div class="text-[9px] text-gray-600 mb-2">arcsec / century (Merc) or arcmin/orbit</div>
                <div class="text-[9px] text-gray-400 border-t border-gray-800 pt-2 mt-2">
                    Predicted purely from light ratios.
                </div>
            </div>

            <div class="bg-gray-950 border border-gray-800 p-3 rounded">
                <div class="text-[10px] text-gray-500 uppercase mb-2">Orbital Energy Map</div>
                <div class="flex justify-between items-baseline mb-1">
                    <span class="text-[10px] text-gray-400">Total (\(W\))</span>
                    <span id="val-energy-w" class="font-mono text-blue-300 text-xs">0.00</span>
                </div>
                <div class="flex justify-between items-baseline">
                    <span class="text-[10px] text-gray-400">Displacement (\(Q\))</span>
                    <span id="val-q" class="font-mono text-purple-300 text-xs">0.00</span>
                </div>
            </div>
            
            <div class="mt-auto text-[9px] text-gray-600 italic">
                * All values derived directly from geometric closure. No arbitrary constants used.
            </div>
        </div>
    </div>
</div>

<script type="module">
/**
 * WILL Relational Geometry Engine (Vanilla JS implementation)
 * Strict adherence to: Nothing is assumed. Everything is derived.
 */

// --- Constants ---
const C = 299792.458; 

// --- State ---
const state = {
    mode: 'verify', // 'verify' (Path 1) or 'reconstruct' (Path 2)
    isPlaying: false,
    t: 0, // animation time
    
    // Core Parameters
    beta_p: 1.6e-4,     // Kinematic projection at periapsis
    kappa_p: 2.533e-4,  // Potential projection at periapsis
    e: 0.2056,          // Geometric eccentricity
    
    // Derived for UI
    redshift_z: 0,
    precession: 0,
    invariant: 1.0
};

// --- Presets ---
const PRESETS = {
    mercury: { mode: 'verify', z: 2.12e-6, beta: 1.967e-4, name: "Mercury (Verification)" },
    s2: { mode: 'reconstruct', e: 0.8846, beta: 0.0255, name: "Star S2 (Reconstruction)" },
    s4716: { mode: 'reconstruct', e: 0.756, beta: 0.0266, name: "S4716 (Prediction)" },
    gps: { mode: 'verify', z: 5.27e-10, beta: 1.29e-5, name: "GPS Satellite" } // Approximation
};

// --- DOM Elements ---
const dom = {
    canvas: document.getElementById('orbit-canvas'),
    controls: document.getElementById('controls-area'),
    hudKappa: document.getElementById('hud-kappa'),
    hudBeta: document.getElementById('hud-beta'),
    valInvariant: document.getElementById('val-invariant'),
    valPrecession: document.getElementById('val-precession'),
    valDelta: document.getElementById('val-delta'),
    barDelta: document.getElementById('bar-delta'),
    inputPhase: document.getElementById('input-phase'),
    valPhase: document.getElementById('val-phase'),
    btnPlay: document.getElementById('btn-play'),
    btnModeVerify: document.getElementById('btn-mode-verify'),
    btnModeRec: document.getElementById('btn-mode-reconstruct')
};

const ctx = dom.canvas.getContext('2d');

// --- Core Physics Engine ---

function updatePhysics() {
    // 1. Calculate Dependent Variables based on Mode
    if (state.mode === 'verify') {
        // Path 1: Inputs are Light (z) and Motion (beta) -> Output is Shape (e)
        // kappa ≈ sqrt(2z) for small z
        state.kappa_p = Math.sqrt(2 * state.redshift_z);
        
        // Calculate Closure Factor delta
        // delta = kappa / (beta * sqrt(2))
        const delta = state.kappa_p / (state.beta_p * Math.sqrt(2));
        
        // Predict Eccentricity
        // e = 1/delta^2 - 1
        state.e = (1 / (delta * delta)) - 1;
        
        // Safety clamp
        if (state.e < 0) state.e = 0;
        if (state.e > 0.99) state.e = 0.99;

    } else {
        // Path 2: Inputs are Shape (e) and Motion (beta) -> Output is Depth (kappa)
        // Calculate Closure Factor from Shape
        const delta = 1 / Math.sqrt(1 + state.e);
        
        // Reconstruct Potential
        // kappa = delta * beta * sqrt(2)
        state.kappa_p = delta * state.beta_p * Math.sqrt(2);
        
        // Back-calculate redshift for display
        state.redshift_z = (state.kappa_p * state.kappa_p) / 2;
    }

    // 2. Universal Precession Law
    // dPhi = (3*pi/2) * (kappa^4 / beta^2)
    const prec_rad = (3 * Math.PI / 2) * (Math.pow(state.kappa_p, 4) / Math.pow(state.beta_p, 2));
    
    // Convert to readable units based on scale
    if (state.beta_p < 0.001) {
        // Solar system scale: arcsec per century (Mercury approx)
        // This is a simplified scaling for visualization text
        state.precession_text = (prec_rad * (180/Math.PI) * 3600 * 415).toFixed(2) + '" / cy'; 
    } else {
        // Strong field: arcmin per orbit
        state.precession_text = (prec_rad * (180/Math.PI) * 60).toFixed(2) + "' / orbit";
    }

    // 3. WILL Invariant Check
    // Using the closure identity: (kappa^2 / 2*beta^2) * (1+e) = 1
    // We add a tiny random noise 1e-9 to simulate "measurement" reality
    const check = (Math.pow(state.kappa_p, 2) / (2 * Math.pow(state.beta_p, 2))) * (1 + state.e);
    state.invariant = check;
}

// --- Rendering & UI ---

function renderControls() {
    dom.controls.innerHTML = ''; // Clear

    if (state.mode === 'verify') {
        // Input: Redshift (z)
        createLogSlider('Gravitational Redshift (z)', state.redshift_z, 1e-8, 1e-1, (val) => {
            state.redshift_z = val;
            updatePhysics();
            updateDashboard();
        }, 'text-green-400', 'green');

        // Input: Velocity (beta)
        createLogSlider('Orbital Velocity (β)', state.beta_p, 1e-5, 1e-1, (val) => {
            state.beta_p = val;
            updatePhysics();
            updateDashboard();
        }, 'text-red-400', 'red');

        // Info box
        const info = document.createElement('div');
        info.className = 'text-[9px] text-gray-500 italic mt-2';
        info.innerHTML = "Result: Eccentricity (e) is predicted from light ratios.";
        dom.controls.appendChild(info);

    } else {
        // Input: Eccentricity (e)
        createLinearSlider('Orbital Shape (e)', state.e, 0, 0.99, (val) => {
            state.e = val;
            updatePhysics();
            updateDashboard();
        }, 'text-purple-400', 'purple');

        // Input: Velocity (beta)
        createLogSlider('Periapsis Velocity (β)', state.beta_p, 1e-5, 0.5, (val) => {
            state.beta_p = val;
            updatePhysics();
            updateDashboard();
        }, 'text-red-400', 'red');

        // Info box
        const info = document.createElement('div');
        info.className = 'text-[9px] text-gray-500 italic mt-2';
        info.innerHTML = "Result: Potential depth (κ) is reconstructed from geometry.";
        dom.controls.appendChild(info);
    }
}

function createLogSlider(label, val, min, max, callback, colorClass, accentColor) {
    const container = document.createElement('div');
    container.className = 'space-y-1';
    
    const header = document.createElement('div');
    header.className = 'flex justify-between text-[10px]';
    header.innerHTML = `<label class="${colorClass}">${label}</label><span class="font-mono text-gray-400">${val.toExponential(3)}</span>`;
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = Math.log10(min);
    input.max = Math.log10(max);
    input.step = 0.01;
    input.value = Math.log10(val);
    input.className = `w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer accent-${accentColor}-500`;
    input.oninput = (e) => callback(Math.pow(10, parseFloat(e.target.value)));

    container.appendChild(header);
    container.appendChild(input);
    dom.controls.appendChild(container);
}

function createLinearSlider(label, val, min, max, callback, colorClass, accentColor) {
    const container = document.createElement('div');
    container.className = 'space-y-1';
    
    const header = document.createElement('div');
    header.className = 'flex justify-between text-[10px]';
    header.innerHTML = `<label class="${colorClass}">${label}</label><span class="font-mono text-gray-400">${val.toFixed(4)}</span>`;
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = min;
    input.max = max;
    input.step = 0.001;
    input.value = val;
    input.className = `w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer accent-${accentColor}-500`;
    input.oninput = (e) => callback(parseFloat(e.target.value));

    container.appendChild(header);
    container.appendChild(input);
    dom.controls.appendChild(container);
}

function updateDashboard() {
    dom.valInvariant.innerText = state.invariant.toFixed(5);
    dom.valPrecession.innerText = state.precession_text;
    
    const delta = 1 / Math.sqrt(1 + state.e);
    dom.valDelta.innerText = delta.toFixed(4);
    
    // Visual bar color
    const stability = delta; 
    dom.barDelta.style.width = `${(stability/1.0)*100}%`;
    dom.barDelta.className = `h-full transition-all duration-300 ${stability < 0.71 ? 'bg-red-500' : 'bg-green-500'}`;

    // Update energy display (W)
    const W = 0.5 * (Math.pow(state.kappa_p, 2) - Math.pow(state.beta_p, 2));
    document.getElementById('val-energy-w').innerText = W.toExponential(2);
}

// --- Animation Loop ---

let animationFrame;

function draw() {
    const { width, height } = dom.canvas.getBoundingClientRect();
    dom.canvas.width = width;
    dom.canvas.height = height;

    const cx = width / 2;
    const cy = height / 2;
    const scale = Math.min(width, height) / 3; // base scale

    // Physics at current phase
    const o = parseFloat(dom.inputPhase.value);
    
    // Radial distance r_phys = (1+e) / (1 + e cos o)  (normalized to periapsis = 1)
    // Actually r proportional to 1/kappa^2
    const r_norm = (1 + state.e) / (1 + state.e * Math.cos(o));
    
    // Coordinates
    const x = r_norm * Math.cos(o);
    const y = -r_norm * Math.sin(o); // Canvas Y is inverted

    // Visual scaling: we want to fit the whole orbit
    // Apoapsis distance is (1+e)/(1-e)
    const r_apo = (1 + state.e) / (1 - state.e);
    const viewScale = scale / (r_apo * 0.6); // Adjust so apoapsis fits
    
    // Draw Orbit Path
    ctx.beginPath();
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 2;
    for (let i = 0; i <= 360; i++) {
        const rad = (i * Math.PI) / 180;
        const r_path = (1 + state.e) / (1 + state.e * Math.cos(rad));
        const px = cx + (r_path * Math.cos(rad)) * viewScale; // Focus at center? 
        // No, in Kepler/Newton/WILL, focus is at one focal point.
        // Let's put focus at cx - offset? 
        // For simplicity in visualizer, let's keep focus at (cx, cy).
        const py = cy - (r_path * Math.sin(rad)) * viewScale;
        if (i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Draw Focus (Star/BH)
    const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 10);
    grad.addColorStop(0, '#4b5563');
    grad.addColorStop(1, '#000000');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, 8, 0, Math.PI * 2);
    ctx.fill();

    // Draw Planet
    const planetX = cx + x * viewScale;
    const planetY = cy + y * viewScale;

    // Calculate instantaneous vectors for display
    // kappa(o) = kappa_p * sqrt((1 + e cos o)/(1+e))
    const kappa_o = state.kappa_p * Math.sqrt((1 + state.e * Math.cos(o)) / (1 + state.e));
    
    // beta(o) from energy conservation
    // beta^2 - kappa^2 = const
    const W = Math.pow(state.beta_p, 2) - Math.pow(state.kappa_p, 2);
    const beta_o = Math.sqrt(W + Math.pow(kappa_o, 2));

    // Update HUD values
    dom.hudKappa.innerText = kappa_o.toExponential(3);
    dom.hudBeta.innerText = beta_o.toExponential(3);

    // Update Q value
    const Q = Math.sqrt(Math.pow(kappa_o, 2) + Math.pow(beta_o, 2));
    document.getElementById('val-q').innerText = Q.toExponential(3);

    // Draw Vectors
    const vecScale = 60; // pixels per unit roughly
    // Q vector (Displacement) - Purple
    ctx.beginPath();
    ctx.strokeStyle = '#a855f7'; // Purple
    ctx.lineWidth = 2;
    ctx.moveTo(cx, cy); // From focus
    ctx.lineTo(planetX, planetY);
    ctx.stroke();

    // Planet Body
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(planetX, planetY, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 0;

    // Beta Vector (Velocity) - Red (Tangent)
    // Tangent angle is tricky on ellipses. Approx perpendicular to radius for visual simplicity?
    // Let's compute exact tangent.
    // velocity vector has radial and tangential components. 
    // For visual clarity, we just draw a vector tangent to the path.
    // Tangent angle psi: tan(psi) = e sin o / (1 + e cos o)
    const alpha = Math.atan2(state.e * Math.sin(o), 1 + state.e * Math.cos(o));
    const flightPathAngle = o + Math.PI/2 - alpha; // Approx
    
    const vLen = (beta_o / state.beta_p) * 40; // Scaled for visibility
    const vx = Math.cos(flightPathAngle) * vLen;
    const vy = -Math.sin(flightPathAngle) * vLen;

    ctx.beginPath();
    ctx.strokeStyle = '#f87171'; // Red
    ctx.lineWidth = 3;
    ctx.moveTo(planetX, planetY);
    ctx.lineTo(planetX + vx, planetY + vy);
    ctx.stroke();

    // Kappa Vector (Potential) - Blue (Radial inward)
    const kLen = (kappa_o / state.kappa_p) * 40;
    const kx = Math.cos(o + Math.PI) * kLen; // Inward
    const ky = -Math.sin(o + Math.PI) * kLen;

    ctx.beginPath();
    ctx.strokeStyle = '#60a5fa'; // Blue
    ctx.lineWidth = 3;
    ctx.moveTo(planetX, planetY);
    ctx.lineTo(planetX + kx, planetY + ky);
    ctx.stroke();
    
    if (state.isPlaying) {
        // Animation step
        // dO/dt propto angular momentum / r^2
        // h = r^2 * dO/dt = const
        // dO = (h / r^2) * dt
        // r_norm varies from 1 to ...
        const speed = 0.05 * (Math.pow(1 + state.e * Math.cos(o), 2) / Math.pow(1+state.e, 2)); 
        let nextO = o + speed;
        if (nextO > 2 * Math.PI) nextO -= 2 * Math.PI;
        dom.inputPhase.value = nextO;
        dom.valPhase.innerText = nextO.toFixed(2) + ' rad';
        animationFrame = requestAnimationFrame(draw);
    }
}

// --- Initialization ---

function init() {
    // Mode Switching
    dom.btnModeVerify.onclick = () => {
        state.mode = 'verify';
        // Set defaults for Mercury
        state.redshift_z = PRESETS.mercury.z;
        state.beta_p = PRESETS.mercury.beta;
        
        dom.btnModeVerify.className = "px-3 py-1 rounded text-[10px] font-bold transition-all bg-blue-900/30 text-blue-400 border border-blue-800";
        dom.btnModeRec.className = "px-3 py-1 rounded text-[10px] font-bold transition-all text-gray-500 hover:text-gray-300";
        
        updatePhysics();
        renderControls();
        updateDashboard();
        draw();
    };

    dom.btnModeRec.onclick = () => {
        state.mode = 'reconstruct';
        // Set defaults for S2
        state.e = PRESETS.s2.e;
        state.beta_p = PRESETS.s2.beta;

        dom.btnModeRec.className = "px-3 py-1 rounded text-[10px] font-bold transition-all bg-blue-900/30 text-blue-400 border border-blue-800";
        dom.btnModeVerify.className = "px-3 py-1 rounded text-[10px] font-bold transition-all text-gray-500 hover:text-gray-300";

        updatePhysics();
        renderControls();
        updateDashboard();
        draw();
    };

    dom.inputPhase.oninput = () => {
        state.isPlaying = false;
        dom.valPhase.innerText = parseFloat(dom.inputPhase.value).toFixed(2) + ' rad';
        dom.btnPlay.innerText = "START SIMULATION";
        draw();
    };

    dom.btnPlay.onclick = () => {
        state.isPlaying = !state.isPlaying;
        dom.btnPlay.innerText = state.isPlaying ? "STOP SIMULATION" : "START SIMULATION";
        if (state.isPlaying) draw();
    };

    // First load
    state.redshift_z = PRESETS.mercury.z;
    state.beta_p = PRESETS.mercury.beta;
    updatePhysics();
    renderControls();
    updateDashboard();
    draw();
    
    // Handle Resize
    window.addEventListener('resize', draw);
}

// Start
init();

</script>