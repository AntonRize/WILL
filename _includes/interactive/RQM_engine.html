<script>
/**
 * WILL RG: Geometric Phase Space Calculator (CORRECTED v1.3)
 * -----------------------------------------------------------
 * Strictly follows the "Sulfur Algorithm" verified in Desmos.
 */
function calculateWILL(Z, electronConfig) {

    // --- 1. FUNDAMENTAL CONSTANTS ---
    const WILL_CONSTANTS = {
        DELTA_Z: 1 - 1 / Math.sqrt(2),
        GAMMA_3D: Math.sqrt(1.5)
    };
    // The Max Shielding of a Closed s-pair (Base Strength)
    WILL_CONSTANTS.SIGMA_PAIR = 2 - WILL_CONSTANTS.DELTA_Z;


    // --- 2. GEOMETRIC HELPER FUNCTIONS ---
    function getEccentricity(n, type) {
        const k = (type === 's') ? 1 : 2;
        if (k > n) return 0;
        return Math.sqrt(1 - Math.pow(k / n, 2));
    }

    function getTopologyTax(p_count) {
        if (p_count <= 0) return 0;
        // Linear Chain Base
        const baseLinks = p_count - 1; 
        // Volumetric Expansion (starts at 4th electron, max 2 links)
        const volumetricLinks = Math.min(2, Math.max(0, p_count - 3));
        const volCost = WILL_CONSTANTS.GAMMA_3D - 1;
        
        return (baseLinks + (volumetricLinks * volCost)) * WILL_CONSTANTS.DELTA_Z;
    }


    // --- 3. CONFIGURATION PARSING ---
    let maxN = 0;
    electronConfig.forEach(o => { if (o.n > maxN) maxN = o.n; });

    let coreElectrons = 0;
    let coreSubshells = 0;
    let valenceS = 0;
    let valenceP = 0;
    
    electronConfig.forEach(orbital => {
        if (orbital.n < maxN) {
            coreElectrons += orbital.count;
            coreSubshells++; 
        } else {
            if (orbital.type === 's') valenceS += orbital.count;
            if (orbital.type === 'p') valenceP += orbital.count;
        }
    });


    // --- 4. THE CALCULATION PIPELINE (GEOMETRIC LAW) ---

    // A. Core Screening (Fixed)
    const screenCore = coreElectrons - (coreSubshells * WILL_CONSTANTS.DELTA_Z);

    // B. Leakage Screening (Power Law)
    // We do NOT sum up electrons individually. We calculate the degradation of the s-fence.
    let screenLeakage = 0;
    let s_eccentricity = 0;

    if (valenceS === 2 && valenceP > 0) {
        // [SCENARIO 1]: P-Block Element (e.g. Sulfur)
        // The s-pair acts as a "Holey Fence".
        
        s_eccentricity = getEccentricity(maxN, 's');
        
        // "Excess" p-electrons that punch through the fence.
        // First 2 p-electrons are shadowed. 3rd, 4th, etc. degrade the screen.
        const degradationPower = Math.max(0, valenceP - 2);
        
        // THE GEOMETRIC FORMULA:
        // Screen = Base_Strength * (Eccentricity ^ Degradation)
        screenLeakage = WILL_CONSTANTS.SIGMA_PAIR * Math.pow(s_eccentricity, degradationPower);

    } else if (valenceS > 0 && valenceP === 0) {
        // [SCENARIO 2]: S-Block Element (e.g. Magnesium)
        // If s-shell is full (2), one screens the other with max strength.
        // If s-shell is 1, there is no s-screen (only core).
        if (valenceS === 2) screenLeakage = WILL_CONSTANTS.SIGMA_PAIR;
    }
    // Note: If valenceS is not full (1) and we have P electrons, that's an excited state,
    // not covered by the ground-state engine.


    // C. Topology Tax
    const taxTopology = getTopologyTax(valenceP);


    // --- 5. FINAL SUMMATION ---
    const zEff = Z - screenCore - screenLeakage - taxTopology;

    return {
        effectiveCharge: parseFloat(zEff.toFixed(4)),
        
        screeningBreakdown: {
            // [UI COMPATIBILITY]: Added 'total' so the website can display it.
            total: parseFloat((screenCore + screenLeakage).toFixed(4)),
            core: parseFloat(screenCore.toFixed(4)),
            leakage: parseFloat(screenLeakage.toFixed(4)),
            topology_tax: parseFloat(taxTopology.toFixed(4))
        },
        
        geometry: {
            n: maxN,
            s_eccentricity: parseFloat(s_eccentricity.toFixed(5)),
            // [UI COMPATIBILITY]: UI expects 'p_topology_tax' variable name.
            p_topology_tax: parseFloat(taxTopology.toFixed(4)),
            p_count: valenceP
        },
        
        details: `Z=${Z}: Core=${screenCore.toFixed(3)} | Leakage=${screenLeakage.toFixed(3)} | Tax=${taxTopology.toFixed(3)}`
    };
}
</script>