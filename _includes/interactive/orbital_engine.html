<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<div id="rom-engine-root" style="width: 100%; display: flex; flex-direction: column;"></div>

{% raw %}
<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const G = 6.67430e-11;
    const M_SUN = 1.989e30; 
    const C = 299792458; 

    const RomEngine = () => {
        // --- STATE ---
        const [zInput, setZInput] = useState(0.64); 
        const [betaInput, setBetaInput] = useState(0.65);
        const [rpStr, setRpStr] = useState("1.5e11");
        const [rpPhys, setRpPhys] = useState(1.5e11);

        const canvasRef = useRef(null);

        // --- HANDLER ---
        const handleRpChange = (e) => {
            const val = e.target.value;
            setRpStr(val);
            const num = parseFloat(val);
            if (!isNaN(num) && num > 0) setRpPhys(num);
        };

        // --- PHYSICS KERNEL ---
        const physics = useMemo(() => {
            const one_plus_z = 1 + zInput;
            const Q_p = Math.sqrt(1 - (1 / (one_plus_z * one_plus_z)));

            const isImpossible = betaInput >= Q_p;
            const effectiveBeta = Math.min(betaInput, Q_p - 0.00001);

            const kappa_p = Math.sqrt(Math.max(0, Q_p**2 - effectiveBeta**2));

            let e = 0;
            let isOpen = false;
            
            if (kappa_p > 0.0001) {
                const ratio = (2 * effectiveBeta**2) / (kappa_p**2);
                e = Math.abs(ratio - 1);
            } else {
                e = 1.0; 
            }
            
            if (e >= 1.0) isOpen = true;

            const Rs = (kappa_p**2) * rpPhys;
            const M = (Rs * C**2) / (2 * G);

            return { z: zInput, beta: betaInput, effectiveBeta, r_p: rpPhys, Q_p, kappa_p, e, M, isImpossible, isOpen };
        }, [zInput, betaInput, rpPhys]);

        // --- VISUALIZATION ---
        useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            const w = rect.width;
            const h = rect.height;
            const cx = w / 2;
            const cy = h / 2;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();

            if (physics.isImpossible) {
                ctx.fillStyle = '#FF4444'; ctx.textAlign = 'center'; 
                ctx.font = 'bold 14px monospace';
                ctx.fillText(`IMPOSSIBLE STATE`, cx, cy - 15);
                ctx.font = '12px monospace';
                ctx.fillText(`β_p > Q_p`, cx, cy + 5);
                return;
            }

            let scale = Math.min(w, h) * 0.35;
            if (physics.e > 1.2) scale *= 0.6;

            ctx.beginPath();
            ctx.lineWidth = 2;
            if (physics.isOpen) ctx.strokeStyle = '#FF4444'; 
            else if (physics.e < 0.01) ctx.strokeStyle = '#00FF88';
            else ctx.strokeStyle = '#00F0FF';

            const steps = 400;
            let limit = Math.PI;
            if (physics.isOpen) limit = Math.acos(-1 / physics.e) - 0.15;

            let first = true;
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * 2 * limit - limit;
                const p_norm = Math.abs(1 - physics.e**2); 
                const r = p_norm / (1 + physics.e * Math.cos(t));
                const r_px = r * scale;
                const x = r_px * Math.cos(t);
                const y = r_px * Math.sin(t);
                if (first) { ctx.moveTo(cx + x, cy - y); first = false; }
                else { ctx.lineTo(cx + x, cy - y); }
            }
            ctx.stroke();

            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();

            if (physics.kappa_p > 0) {
                const tx = w - 60;
                const ty = h - 50;
                const tScale = 100;

                const b_len = physics.effectiveBeta * tScale;
                const k_len = physics.kappa_p * tScale;

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00F0FF'; ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx + b_len, ty); ctx.stroke();
                ctx.strokeStyle = '#FF0055'; ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx, ty - k_len); ctx.stroke();
                ctx.strokeStyle = '#FFF'; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(tx + b_len, ty); ctx.lineTo(tx, ty - k_len); ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#ccc'; ctx.font = '11px monospace'; ctx.textAlign = 'center';
                ctx.fillText('β_p', tx + b_len/2, ty + 15);
                ctx.fillText('κ_p', tx - 15, ty - k_len/2);
                ctx.fillStyle = '#FFF';
                ctx.fillText('Q_p', tx + b_len/2 + 5, ty - k_len/2 - 5);
            }

        }, [physics]);

        const labelStyle = { color: '#999', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px', marginBottom: '4px', fontWeight: 'bold' };
        const valStyle = { fontSize: '18px', fontWeight: 'bold', fontFamily: 'monospace' }; // UNIFIED SIZE
        const numInputStyle = { background: '#111', border: '1px solid #444', color: '#fff', padding: '6px', fontSize: '14px', borderRadius: '4px', minWidth: '70px', textAlign: 'right' };
        
        return (
            <div style={{ fontFamily: "'Courier New', monospace", display: 'flex', flexDirection: 'column', width: '100%', background: '#000' }}>
                
                {/* --- OUTPUTS (Balanced) --- */}
                <div style={{ padding: '20px 20px', borderBottom: '1px solid #222', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', background: '#050505' }}>
                    
                    {/* LEFT: MASS */}
                    <div>
                        <div style={labelStyle}>Derived Mass (M)</div>
                        <div style={{...valStyle, color: '#FFD700'}}>
                            {(physics.M / M_SUN).toFixed(2)} M☉
                        </div>
                        <div style={{fontSize: '12px', color: '#666', marginTop:'2px'}}>
                            {physics.M.toExponential(2)} kg
                        </div>
                    </div>
                    
                    {/* RIGHT: ECCENTRICITY (Matching Size) */}
                    <div style={{textAlign: 'right'}}>
                        <div style={labelStyle}>ECCENTRICITY (e)</div>
                        <div style={{...valStyle, color: '#FFF'}}>
                            {physics.e.toFixed(4)}
                        </div>
                        <div style={{fontSize: '12px', marginTop: '2px', color: physics.isOpen ? '#FF4444' : '#00FF88', fontWeight: 'bold'}}>
                            {physics.isOpen ? 'OPEN TRAJECTORY' : 'STABLE ORBIT'}
                        </div>
                    </div>
                </div>

                <div style={{ position: 'relative', height: '400px', width: '100%', background: '#000' }}>
                    <canvas ref={canvasRef} style={{width: '100%', height: '100%', display: 'block'}} />
                    <div style={{position: 'absolute', bottom: 10, left: 10, fontSize: '10px', color: '#333'}}>R.O.M. KERNEL v3.2</div>
                </div>

                {/* --- INPUTS --- */}
                <div style={{ padding: '20px', background: '#080808', borderTop: '1px solid #222', display: 'flex', flexWrap: 'wrap', gap: '20px', alignItems: 'flex-start' }}>
                    
                    <div style={{flex: '1 1 250px'}}>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:'5px'}}>
                            <span style={labelStyle}>Shift (z_Qp)</span>
                            <span style={{color: '#FF0055', fontSize:'14px', fontWeight:'bold'}}>{physics.z.toFixed(3)}</span>
                        </div>
                        <div style={{display:'flex', gap:'10px', alignItems:'center'}}>
                            <input type="range" min="0.01" max="3.0" step="0.01" value={zInput} onChange={e => setZInput(parseFloat(e.target.value))} style={{flex: 1, height: '30px', accentColor: '#FF0055', cursor: 'pointer'}} />
                            <input type="number" step="0.01" value={zInput} onChange={e => setZInput(parseFloat(e.target.value))} style={numInputStyle} />
                        </div>
                    </div>

                    <div style={{flex: '1 1 250px'}}>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:'5px'}}>
                            <span style={labelStyle}>Velocity (β_p)</span>
                            <span style={{color: '#00F0FF', fontSize:'14px', fontWeight:'bold'}}>{physics.beta.toFixed(3)}</span>
                        </div>
                        <div style={{display:'flex', gap:'10px', alignItems:'center'}}>
                            <input type="range" min="0.001" max={physics.Q_p || 1} step="0.001" value={betaInput} onChange={e => setBetaInput(parseFloat(e.target.value))} style={{flex: 1, height: '30px', accentColor: '#00F0FF', cursor: 'pointer'}} />
                            <input type="number" step="0.001" value={betaInput} onChange={e => setBetaInput(parseFloat(e.target.value))} style={numInputStyle} />
                        </div>
                        {physics.isImpossible && <div style={{color:'#FF4444', fontSize:'10px', marginTop:'4px'}}>⚠ Exceeds Q_p Limit</div>}
                    </div>

                    <div style={{flex: '1 1 200px'}}>
                        <div style={{marginBottom:'5px', ...labelStyle}}>Periapsis r_p (m)</div>
                        <input 
                            type="text" 
                            value={rpStr} 
                            onChange={handleRpChange}
                            placeholder="e.g. 1.5e11"
                            style={{...numInputStyle, width: '100%', textAlign: 'left', padding: '10px'}}
                        />
                        <div style={{fontSize:'10px', color:'#444', marginTop:'2px'}}>
                            Supports scientific notation (e.g. 2.5e13)
                        </div>
                    </div>

                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('rom-engine-root'));
    root.render(<RomEngine />);
</script>
{% endraw %}