<div class="flex flex-col md:flex-row h-[90vh] bg-[#050505] text-gray-300 font-sans text-xs select-none shadow-2xl border border-gray-900 rounded-lg overflow-hidden">

    <div class="w-full md:w-96 bg-gray-900/90 backdrop-blur border-r border-gray-800 flex flex-col z-10 shrink-0 relative">
        
        <div class="p-4 border-b border-gray-800 bg-black">
            <h2 class="text-sm font-bold text-white tracking-widest uppercase flex items-center gap-2 mb-3">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                WILL Relational Engine
            </h2>
            
            <div class="flex bg-gray-800 rounded p-1 gap-1">
                <button onclick="setMode('interactive')" id="tab-interactive" class="flex-1 py-1 px-1 rounded text-[9px] font-bold bg-gray-600 text-white transition-all">MANUAL</button>
                <button onclick="setMode('triangulate')" id="tab-triangulate" class="flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 transition-all">3-POINT NAV</button>
            </div>
        </div>

        <div id="panel-interactive" class="p-4 space-y-4 border-b border-gray-800">
            <div class="text-[9px] uppercase tracking-wider text-blue-400 font-bold">Phase Space Drag</div>
            <div class="space-y-1 font-mono bg-black/30 p-2 rounded border border-gray-800">
                <div class="flex justify-between"><span class="text-blue-400">Kinetic \(\beta_p\)</span><span id="val-beta">0.000</span></div>
                <div class="flex justify-between"><span class="text-red-400">Potential \(\kappa_p\)</span><span id="val-kappa">0.000</span></div>
            </div>
        </div>

        <div id="panel-triangulate" class="p-4 space-y-4 border-b border-gray-800 hidden">
            <div class="text-[9px] uppercase tracking-wider text-purple-400 font-bold">Orbital Triangulation</div>
            <div class="text-gray-500 italic mb-2">Solves Mass & Orbit using acceleration curvature.</div>
            
            <div class="space-y-3 relative">
                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T1</div>
                    <div class="col-span-10"><input type="number" id="v1" placeholder="Velocity 1 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>
                
                <div class="flex justify-center -my-2 z-10 relative"><span class="bg-gray-800 text-[9px] px-2 rounded text-gray-400">Time: <input type="number" id="dt1" class="w-12 bg-black border border-gray-600 text-center text-white" value="10"> days</span></div>

                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T2</div>
                    <div class="col-span-10"><input type="number" id="v2" placeholder="Velocity 2 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>

                <div class="flex justify-center -my-2 z-10 relative"><span class="bg-gray-800 text-[9px] px-2 rounded text-gray-400">Time: <input type="number" id="dt2" class="w-12 bg-black border border-gray-600 text-center text-white" value="10"> days</span></div>

                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T3</div>
                    <div class="col-span-10"><input type="number" id="v3" placeholder="Velocity 3 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>
                
                <button onclick="solveTriangulation()" class="w-full py-3 bg-purple-900/40 border border-purple-800 text-purple-300 rounded font-bold hover:bg-purple-900/60 flex justify-center items-center gap-2 transition-all mt-2">
                    <span id="loader-tri" class="hidden w-3 h-3 border-2 border-purple-300 border-t-transparent rounded-full animate-spin"></span>
                    TRIANGULATE SYSTEM
                </button>
            </div>

            <div id="tri-result" class="hidden space-y-2 bg-purple-900/10 p-2 rounded border border-purple-900/30 mt-2">
                <div class="text-[9px] text-purple-400 font-bold border-b border-purple-900/30 pb-1 mb-1">FOUND SOLUTION:</div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Mass (Mâ˜‰):</span> <span id="out-mass" class="text-white font-bold text-green-400">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Eccentricity:</span> <span id="out-e" class="text-white font-bold text-blue-400">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Period:</span> <span id="out-period" class="text-white">-</span></div>
                <div class="text-[9px] text-gray-500 mt-1 italic text-center">Converged with <span id="out-err">-</span>% error</div>
            </div>
        </div>

        <div class="p-4 space-y-6 overflow-y-auto flex-1 bg-black/20">
            <div>
                <div class="text-[9px] uppercase tracking-wider text-gray-500 font-bold mb-2">System State</div>
                <div class="space-y-2 font-mono">
                    <div class="flex justify-between items-center bg-gray-900 p-2 rounded border border-gray-800">
                        <span class="text-gray-400">Eccentricity \(e\)</span>
                        <span id="val-e" class="text-white text-lg font-bold">0.000</span>
                    </div>
                    <div class="bg-gray-900 p-2 rounded border border-gray-800">
                        <div class="flex justify-between text-[10px] text-gray-400">
                            <span>Closure (\(\delta\))</span><span id="val-delta">1.00</span>
                        </div>
                        <div class="w-full h-1 bg-gray-800 rounded-full mt-1"><div id="bar-delta" class="h-full bg-blue-500 w-full"></div></div>
                    </div>
                </div>
            </div>
            <div id="zone-badge" class="py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-gray-800 text-gray-500 border border-gray-700">-</div>
        </div>
    </div>

    <div class="flex-1 relative bg-black cursor-crosshair overflow-hidden" id="sim-container">
        <canvas id="mainCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        <div class="absolute bottom-4 right-4 bg-black/80 backdrop-blur p-3 rounded border border-gray-800 text-[10px] space-y-2 pointer-events-none">
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-green-500/50 border-t border-dashed border-green-400"></span><span>Circle Line</span></div>
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-red-500/50 border-t border-dashed border-red-400"></span><span>Escape Line</span></div>
             <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-white border-t border-white"></span><span>Observed Arc</span></div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('sim-container');
    const c = 299792.458; 

    // State
    let mode = 'interactive';
    let beta_p = 0.4;
    let kappa_p = 0.4 * Math.sqrt(2);
    let phys = {};
    let dragging = false;
    let width, height, cx, cy, scale;
    let phase = 0;
    
    // Visualization State
    let observedArc = null; // {start, end, points[]}

    // --- PHYSICS KERNEL ---
    function updatePhysics() {
        const denom = (beta_p * Math.SQRT2);
        const delta = denom > 0.00001 ? kappa_p / denom : 0;
        let e = (delta > 0) ? (1 / (delta * delta)) - 1 : 0;
        
        let status = 'stable';
        let e_real = e;
        
        if (kappa_p < beta_p) { status = 'unbound'; e_real = Math.abs(e); }
        else if (kappa_p > beta_p * Math.SQRT2) { status = 'inverted'; e_real = Math.abs(e); }

        const prec = (3 * Math.PI / 2) * (Math.pow(kappa_p, 4) / Math.pow(beta_p, 2));

        phys = { delta, e, e_real, status, prec };
        updateUI();
    }

    // --- SOLVER 3: TRIANGULATION (3 Points) ---
    function solveTriangulation() {
        observedArc = null;
        const v1 = parseFloat(document.getElementById('v1').value);
        const v2 = parseFloat(document.getElementById('v2').value);
        const v3 = parseFloat(document.getElementById('v3').value);
        const dt1 = parseFloat(document.getElementById('dt1').value) * 86400; // sec
        const dt2 = parseFloat(document.getElementById('dt2').value) * 86400; // sec
        
        if(!v1 || !v2 || !v3) return;

        document.getElementById('loader-tri').classList.remove('hidden');
        
        setTimeout(() => {
            // Algorithm:
            // 1. Scan Eccentricity e from 0 to 0.99
            // 2. For each e, find Mass required to fit Interval 1 (v1->v2)
            // 3. For each e, find Mass required to fit Interval 2 (v2->v3)
            // 4. The 'e' where Mass1 == Mass2 is the solution.
            
            const results = scanIntersection(v1, v2, v3, dt1, dt2);
            
            document.getElementById('loader-tri').classList.add('hidden');
            document.getElementById('tri-result').classList.remove('hidden');
            
            if(results.best) {
                const sol = results.best;
                
                // Set Global State
                beta_p = sol.v_p / c; 
                kappa_p = beta_p * Math.SQRT2 / Math.sqrt(1 + sol.e);
                
                // Output
                const M_sun = sol.M / 1.989e30;
                let m_fmt = M_sun < 0.01 ? M_sun.toExponential(2) : M_sun.toFixed(2);
                
                document.getElementById('out-mass').innerText = m_fmt;
                document.getElementById('out-e').innerText = sol.e.toFixed(4);
                document.getElementById('out-period').innerText = (sol.T / 86400).toFixed(1) + " d";
                document.getElementById('out-err').innerText = (sol.err * 100).toFixed(2);
                
                // Visualization
                observedArc = { start: sol.o1, end: sol.o3 };
                
                updatePhysics();
            } else {
                alert("Solution divergence. Data points may be inconsistent (e.g., v2 is not between v1 and v3 geometrically, or noise is too high).");
            }
        }, 50);
    }

    function scanIntersection(v1, v2, v3, dt1, dt2) {
        let bestError = Infinity;
        let bestSol = null;
        
        // Coarse scan then fine? Just coarse for demo (step 0.01)
        for(let e = 0.01; e < 0.99; e += 0.01) {
            
            // Interval 1 fit
            const fit1 = fitInterval(e, v1, v2, dt1);
            if(!fit1) continue;
            
            // Interval 2 fit
            // Must verify phase consistency. 
            // If v1>v2, phase is increasing (0 -> pi).
            // o2 from fit1 must match o_start for fit2.
            // But fitInterval finds optimal Mass. 
            // We just check if Mass matches.
            // And we must ensure v2 in fit2 corresponds to same phase as v2 in fit1?
            // Actually, for a fixed e, relative phases are fixed by velocity ratios.
            // Ratio R1 = v1/v2. Ratio R2 = v2/v3.
            
            // Let's deduce phases first.
            // Assume v_max = V_scale * (1+e)/(sqrt(1-e^2)).
            // v(o) = V_scale * (1+e cos o) / sqrt(1-e^2).
            // Ratio v1/v2 = (1+e cos o1)/(1+e cos o2).
            
            // We need to place o1, o2, o3.
            // Assume monotonic segment (e.g. falling from peri).
            // o1 determined by assumption? No, only relative differences matter?
            // Wait, Mass depends on absolute derivative.
            
            // Let's assume v1 is the anchor.
            // But we don't know where v1 is.
            // This is the tricky part. 
            // Actually, with 3 velocities, we have R1 and R2.
            // (1+e cos o1)/(1+e cos o2) = v1/v2
            // (1+e cos o2)/(1+e cos o3) = v2/v3
            // We have 3 phases, 2 equations. Degree of freedom: shift o1.
            // But we have constraints: o2 = o1 + d_o1, o3 = o2 + d_o2.
            // And Time(o1,o2) = dt1 * S. Time(o2,o3) = dt2 * S.
            // S (Scale) must be same.
            
            // This suggests for a fixed e, we must scan o1.
            // Iterate o1 from 0 to PI.
            // Calculate o2 from v1/v2.
            // Calculate o3 from v2/v3.
            // Calculate Time1_dim and Time2_dim (dimensionless).
            // Calculate implied Scale1 = dt1 / Time1_dim.
            // Calculate implied Scale2 = dt2 / Time2_dim.
            // Error = abs(Scale1 - Scale2).
            // Find o1 that minimizes scale error.
            // That gives the best Mass for this 'e'.
            
            // Then, is that 'e' the global best?
            // No, any e might find a matching scale phase.
            // Wait.
            // If we match scales, do we match absolute values?
            // Scale defines GM. 
            // v = sqrt(GM/a) * shape.
            // We matched velocity Ratios.
            // Now we match Time Ratios.
            // Does this fix e?
            // Yes. The "Time-Ratio vs Velocity-Ratio" curve depends on e.
            
            // SIMPLIFIED ALGORITHM for Demo:
            // 1. Scan e.
            // 2. Scan o1.
            // 3. Derive o2, o3 from V ratios.
            // 4. Calc Ratio of Times (dt_dim_1 / dt_dim_2).
            // 5. Compare with Real Ratio (dt1 / dt2).
            // 6. Minimize difference.
            
            // This finds the correct (e, o1).
            // Then we calc Mass from that solution.
            
            const ratioV1 = v1/v2;
            const ratioV2 = v2/v3;
            const targetTimeRatio = dt1/dt2;
            
            for(let o1 = 0; o1 < 3.0; o1 += 0.1) {
                // Solve o2
                // (1+e cos o1)/(1+e cos o2) = R1 => 1+e cos o2 = (1+e cos o1)/R1
                const term2 = (1 + e * Math.cos(o1)) / ratioV1;
                const cos_o2 = (term2 - 1) / e;
                if(Math.abs(cos_o2) > 1) continue;
                const o2 = Math.acos(cos_o2);
                
                // Solve o3
                const term3 = (1 + e * Math.cos(o2)) / ratioV2;
                const cos_o3 = (term3 - 1) / e;
                if(Math.abs(cos_o3) > 1) continue;
                const o3 = Math.acos(cos_o3);
                
                // Ensure order (monotonic fall)
                // If v1 > v2, o1 < o2. If v2 > v3, o2 < o3.
                // acos always returns 0..pi.
                // Assuming v decreasing.
                
                // Calc Dimensionless Times
                const dT1_dim = calcKeplerTime(e, o1, o2);
                const dT2_dim = calcKeplerTime(e, o2, o3);
                
                const timeRatio = dT1_dim / dT2_dim;
                const err = Math.abs(timeRatio - targetTimeRatio) / targetTimeRatio;
                
                if(err < 0.05 && err < bestError) {
                    bestError = err;
                    
                    // Reconstruct Mass
                    // n = dM_dim / dt
                    // a = v / (n * geom)
                    const n = dT1_dim / dt1; // rad/sec approx
                    const V_geo = (1 + e * Math.cos(o1)) / Math.sqrt(1-e*e);
                    const v1_m = v1 * 1000;
                    const a = v1_m / (n * V_geo);
                    const GM = n*n * a*a*a;
                    const Mass = GM / 6.6743e-11;
                    
                    // Calc Periapsis Velocity for display
                    const v_p = n * a * Math.sqrt((1+e)/(1-e)) / 1000;
                    
                    bestSol = { e: e, M: Mass, T: 2*Math.PI/n, v_p: v_p, err: err, o1: o1, o3: o3 };
                }
            }
        }
        return { best: bestSol };
    }
    
    function calcKeplerTime(e, o_start, o_end) {
        // M = E - e sin E
        // tan(E/2) = sqrt((1-e)/(1+e)) tan(o/2)
        const E1 = 2 * Math.atan(Math.sqrt((1-e)/(1+e)) * Math.tan(o_start/2));
        const E2 = 2 * Math.atan(Math.sqrt((1-e)/(1+e)) * Math.tan(o_end/2));
        const M1 = E1 - e * Math.sin(E1);
        const M2 = E2 - e * Math.sin(E2);
        return Math.abs(M2 - M1);
    }

    // --- UI HELPERS ---
    function setMode(m) {
        mode = m;
        ['interactive', 'triangulate'].forEach(k => {
            const pan = document.getElementById('panel-'+k);
            const tab = document.getElementById('tab-'+k);
            if(k === m) {
                pan.classList.remove('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold bg-" + (k==='triangulate'?'purple':'gray') + "-600 text-white transition-all shadow-[0_0_10px_rgba(255,255,255,0.2)]";
            } else {
                pan.classList.add('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 hover:text-white transition-all";
            }
        });
    }

    function updateUI() {
        document.getElementById('val-beta').innerText = beta_p.toFixed(4);
        document.getElementById('val-kappa').innerText = kappa_p.toFixed(4);
        document.getElementById('val-e').innerText = phys.e.toFixed(4);
        document.getElementById('val-delta').innerText = phys.delta.toFixed(3);
        
        const badge = document.getElementById('zone-badge');
        
        if(phys.status === 'unbound') {
            badge.innerText = "UNBOUND";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-red-900/40 text-red-400 border border-red-900";
        } else if(phys.status === 'inverted') {
            badge.innerText = "INVERTED";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-blue-900/40 text-blue-400 border border-blue-900";
        } else {
            badge.innerText = "STABLE";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-green-900/40 text-green-400 border border-green-900";
        }
    }

    // --- LOOP ---
    function resize() {
        const r = container.getBoundingClientRect();
        width = r.width; height = r.height;
        canvas.width = width; canvas.height = height;
        cx = width/2; cy = height/2;
        scale = Math.min(width, height)/3;
    }
    window.onresize = resize;
    
    function loop() {
        let speed = 0.02 * Math.pow(1 + phys.e_real * Math.cos(phase), 2) / Math.pow(1 + Math.abs(phys.e_real), 2);
        if(speed < 0.001) speed = 0.001;
        phase += speed;
        
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
        ctx.save(); ctx.translate(cx,cy); ctx.scale(1,-1);

        let ds = scale;
        const Q = Math.sqrt(beta_p**2 + kappa_p**2);
        if(Q < 0.1 && Q > 1e-6) ds = scale * (0.4/Q);

        ctx.strokeStyle='#111'; ctx.beginPath();
        for(let i=-10;i<=10;i++) { ctx.moveTo(i*ds,-10*ds); ctx.lineTo(i*ds,10*ds); ctx.moveTo(-10*ds,i*ds); ctx.lineTo(10*ds,i*ds); }
        ctx.stroke();

        ctx.strokeStyle='#333'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,ds,0,7); ctx.stroke();

        ctx.strokeStyle = phys.status==='stable'?'#22c55e':(phys.status==='unbound'?'#ef4444':'#3b82f6');
        ctx.beginPath();
        const p_param = Q * ds * (1 + phys.e_real);
        for(let th=0; th<=360; th+=2) {
            const rad = th*Math.PI/180;
            const r = p_param / (1 + phys.e_real*Math.cos(rad));
            if(r<0 || r>20*ds) continue;
            const x = r*Math.cos(rad); const y = r*Math.sin(rad);
            if(th===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        
        if(observedArc && phys.status === 'stable') {
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath();
            const start = observedArc.start; const end = observedArc.end;
            for(let th=start; th<=end; th+=0.05) {
                const r = p_param / (1 + phys.e_real*Math.cos(th));
                const x = r*Math.cos(th); const y = r*Math.sin(th);
                if(th===start) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            ctx.lineWidth=2;
        }

        const ra = p_param / (1 + phys.e_real*Math.cos(phase));
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ra*Math.cos(phase), ra*Math.sin(phase), 4, 0, 7); ctx.fill();

        const qx = beta_p * ds; const qy = kappa_p * ds;
        ctx.lineWidth=2; ctx.strokeStyle='#a855f7'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(qx,qy); ctx.stroke();
        ctx.fillStyle=(mode==='interactive')?'#fff':'#9ca3af'; ctx.beginPath(); ctx.arc(qx,qy, 3, 0, 7); ctx.fill();

        ctx.restore();
        requestAnimationFrame(loop);
    }

    resize();
    updatePhysics();
    loop();
</script>