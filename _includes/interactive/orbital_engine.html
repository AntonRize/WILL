<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<div id="rom-engine-root" style="width: 100%; min-height: 600px; display: flex; flex-direction: column;"></div>

{% raw %}
<script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // --- CONSTANTS ---
    const G = 6.67430e-11;
    const M_SUN = 1.989e30; 
    const C = 299792458; 

    const RomEngine = () => {
        // --- STATE ---
        const [zInput, setZInput] = useState(0.64); 
        const [betaInput, setBetaInput] = useState(0.65);
        const [rpInput, setRpInput] = useState(1.5e11);

        const canvasRef = useRef(null);

        // --- PHYSICS CORE ---
        const physics = useMemo(() => {
            // 1. Q_p (Hypotenuse) from z_Qp
            const one_plus_z = 1 + zInput;
            const Q_p = Math.sqrt(1 - (1 / (one_plus_z * one_plus_z)));

            // 2. Beta Limiter
            // If user typed beta > Q, we physically cap it for calculation to maintain reality
            // But we allow the state to exist briefly to show error, OR we clamp it.
            // Let's clamp the effective beta for physics.
            const effectiveBeta = Math.min(betaInput, Q_p - 0.0001); 
            
            // Logic check for triangle visibility
            const isImpossible = betaInput >= Q_p;

            // 3. Kappa_p (Leg)
            // kappa = sqrt(Q^2 - beta^2)
            const kappa_p = Math.sqrt(Math.max(0, Q_p**2 - effectiveBeta**2));

            // 4. Eccentricity (e)
            // Golden Ratio: Circle when kappa = beta * sqrt(2)
            // e = | (2*beta^2 / kappa^2) - 1 |
            let e = 0;
            let isOpen = false;
            
            if (kappa_p > 0.0001) {
                const ratio = (2 * effectiveBeta**2) / (kappa_p**2);
                e = Math.abs(ratio - 1);
            } else {
                e = 1.0; 
            }
            if (e >= 1.0) isOpen = true;

            // 5. Mass (M)
            const Rs = (kappa_p**2) * rpInput;
            const M = (Rs * C**2) / (2 * G);

            return { 
                z: zInput, 
                beta: betaInput, 
                effectiveBeta,
                r_p: rpInput, 
                Q_p, 
                kappa_p, 
                e, 
                M, 
                isImpossible, 
                isOpen 
            };
        }, [zInput, betaInput, rpInput]);

        // --- VISUALIZATION ---
        useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            // Layout & DPI
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            const w = rect.width;
            const h = rect.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear (Transparent background for canvas to blend, or explicitly black)
            ctx.fillStyle = '#000000'; 
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();

            // Error State
            if (physics.isImpossible) {
                ctx.fillStyle = '#FF4444'; ctx.textAlign = 'center'; ctx.font = '14px monospace';
                ctx.fillText(`IMPOSSIBLE STATE: β_p > Q_p`, cx, cy - 20);
                ctx.font = '10px monospace';
                ctx.fillText(`Kinetic component exceeds Total Energy`, cx, cy);
                return; // Stop drawing orbit
            }

            // Orbit
            let scale = Math.min(w, h) * 0.35;
            if (physics.e > 1.5) scale *= 0.5;

            ctx.beginPath();
            ctx.lineWidth = 2;
            if (physics.isOpen) ctx.strokeStyle = '#FF4444'; 
            else if (physics.e < 0.01) ctx.strokeStyle = '#00FF88';
            else ctx.strokeStyle = '#00F0FF';

            const steps = 400;
            let limit = Math.PI;
            if (physics.isOpen) limit = Math.acos(-1 / physics.e) - 0.1;

            let first = true;
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * 2 * limit - limit;
                const p_norm = Math.abs(1 - physics.e**2); 
                const r = p_norm / (1 + physics.e * Math.cos(t));
                const r_px = r * scale;
                const x = r_px * Math.cos(t);
                const y = r_px * Math.sin(t);
                if (first) { ctx.moveTo(cx + x, cy - y); first = false; }
                else { ctx.lineTo(cx + x, cy - y); }
            }
            ctx.stroke();

            // Focus
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();

            // TRIANGLE (Bottom Right)
            // Hidden if impossible
            if (!physics.isImpossible && physics.kappa_p > 0) {
                const tx = w - 60;
                const ty = h - 50;
                const tScale = 120;

                const b_len = physics.effectiveBeta * tScale;
                const k_len = physics.kappa_p * tScale;

                ctx.lineWidth = 2;
                // Beta
                ctx.strokeStyle = '#00F0FF'; ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx + b_len, ty); ctx.stroke();
                // Kappa
                ctx.strokeStyle = '#FF0055'; ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx, ty - k_len); ctx.stroke();
                // Q
                ctx.strokeStyle = '#FFF'; ctx.setLineDash([4, 4]);
                ctx.beginPath(); ctx.moveTo(tx + b_len, ty); ctx.lineTo(tx, ty - k_len); ctx.stroke();
                ctx.setLineDash([]);

                // Labels
                ctx.fillStyle = '#888'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
                ctx.fillText('β_p', tx + b_len/2, ty + 15);
                ctx.fillText('κ_p', tx - 15, ty - k_len/2);
                ctx.fillStyle = '#FFF';
                ctx.fillText('Q_p', tx + b_len/2 + 10, ty - k_len/2 - 5);
            }

        }, [physics]);

        // STYLES
        const sectionStyle = {
            padding: '15px 20px',
            background: '#050505', // Slightly lighter than pure black to distinguish panels
            borderBottom: '1px solid #222',
            display: 'flex', justifyContent: 'space-between', alignItems: 'center'
        };
        const labelStyle = { color: '#666', fontSize: '10px', textTransform: 'uppercase', letterSpacing: '1px' };
        const valStyle = { fontFamily: 'monospace', fontSize: '14px', color: '#fff' };

        return (
            <div style={{ 
                fontFamily: "'Courier New', monospace", 
                display: 'flex', flexDirection: 'column', 
                height: '650px', 
                // Removed borderRadius and border to fit seamlessly into Jekyll container
                background: '#000' 
            }}>
                
                {/* --- OUTPUTS (TOP) --- */}
                <div style={sectionStyle}>
                    <div>
                        <div style={labelStyle}>Derived Mass (M)</div>
                        <div style={{color: '#FFD700', fontSize: '18px', fontWeight: 'bold', marginTop:'5px'}}>
                            {(physics.M / M_SUN).toFixed(2)} M☉
                        </div>
                        <div style={{fontSize: '11px', color: '#444'}}>
                            {physics.M.toExponential(2)} kg
                        </div>
                    </div>
                    
                    <div style={{textAlign: 'right'}}>
                        <div style={labelStyle}>Trajectory Status</div>
                        <div style={{color: physics.isOpen ? '#FF4444' : '#00FF88', fontSize: '14px', marginTop:'5px'}}>
                            {physics.isOpen ? 'OPEN / ESCAPE' : 'STABLE ORBIT'}
                        </div>
                        <div style={{fontSize: '11px', color: '#666'}}>e = {physics.e.toFixed(4)}</div>
                    </div>
                </div>

                {/* --- CANVAS (MIDDLE) --- */}
                <div style={{ flex: 1, position: 'relative', background: '#000' }}>
                    <canvas ref={canvasRef} style={{width: '100%', height: '100%', display: 'block'}} />
                    <div style={{position: 'absolute', bottom: 10, left: 10, fontSize: '9px', color: '#333'}}>
                        R.O.M. KERNEL v2.2 | NORMALIZED VIEW (a=1)
                    </div>
                </div>

                {/* --- INPUTS (BOTTOM) --- */}
                <div style={{ 
                    padding: '20px', // Uniform padding
                    background: '#080808', 
                    borderTop: '1px solid #222',
                    display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '20px'
                }}>
                    
                    {/* Z Input */}
                    <div>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:'5px'}}>
                            <span style={labelStyle}>Shift (z_Qp)</span>
                            <span style={{color: '#FF0055', fontSize:'12px'}}>{physics.z.toFixed(3)}</span>
                        </div>
                        <div style={{display:'flex', gap:'5px'}}>
                            <input 
                                type="range" min="0.01" max="3.0" step="0.01"
                                value={zInput} onChange={e => setZInput(parseFloat(e.target.value))}
                                style={{width:'100%', accentColor: '#FF0055'}}
                            />
                            <input 
                                type="number" step="0.01" 
                                value={zInput} onChange={e => setZInput(parseFloat(e.target.value))}
                                style={{background:'#111', border:'1px solid #333', color:'#fff', width:'60px', fontSize:'11px'}}
                            />
                        </div>
                    </div>

                    {/* Beta Input */}
                    <div>
                        <div style={{display:'flex', justifyContent:'space-between', marginBottom:'5px'}}>
                            <span style={labelStyle}>Velocity (β_p)</span>
                            <span style={{color: '#00F0FF', fontSize:'12px'}}>{physics.beta.toFixed(3)}</span>
                        </div>
                        <div style={{display:'flex', gap:'5px'}}>
                            <input 
                                type="range" min="0.001" max={physics.Q_p || 1} step="0.001"
                                value={betaInput} onChange={e => setBetaInput(parseFloat(e.target.value))}
                                style={{width:'100%', accentColor: '#00F0FF'}}
                            />
                            <input 
                                type="number" step="0.001" 
                                value={betaInput} onChange={e => setBetaInput(parseFloat(e.target.value))}
                                style={{background:'#111', border:'1px solid #333', color:'#fff', width:'60px', fontSize:'11px'}}
                            />
                        </div>
                    </div>

                    {/* Rp Input */}
                    <div>
                        <div style={{marginBottom:'5px', ...labelStyle}}>Periapsis r_p (m)</div>
                        <input 
                            type="number" 
                            value={rpInput} onChange={e => setRpInput(parseFloat(e.target.value))}
                            style={{
                                width: '100%', background: '#111', border: '1px solid #333', 
                                color: '#fff', padding: '5px', fontFamily: 'monospace'
                            }}
                        />
                    </div>

                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('rom-engine-root'));
    root.render(<RomEngine />);
</script>
{% endraw %}