<div class="flex flex-col md:flex-row h-[90vh] bg-[#050505] text-gray-300 font-sans text-xs select-none shadow-2xl border border-gray-900 rounded-lg overflow-hidden">

    <div class="w-full md:w-96 bg-gray-900/90 backdrop-blur border-r border-gray-800 flex flex-col z-10 shrink-0 relative">
        
        <div class="p-4 border-b border-gray-800 bg-black">
            <h2 class="text-sm font-bold text-white tracking-widest uppercase flex items-center gap-2 mb-3">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                WILL Relational Engine
            </h2>
            
            <div class="flex bg-gray-800 rounded p-1 gap-1">
                <button onclick="setMode('interactive')" id="tab-interactive" class="flex-1 py-1 px-1 rounded text-[9px] font-bold bg-gray-600 text-white transition-all">MANUAL</button>
                <button onclick="setMode('contrast')" id="tab-contrast" class="flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 transition-all">2-PT GEO</button>
                <button onclick="setMode('time')" id="tab-time" class="flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 transition-all">TRUE SOLVER</button>
            </div>
        </div>

        <div id="panel-interactive" class="p-4 space-y-4 border-b border-gray-800">
            <div class="text-[9px] uppercase tracking-wider text-blue-400 font-bold">Phase Space Drag</div>
            <div class="space-y-1 font-mono bg-black/30 p-2 rounded border border-gray-800">
                <div class="flex justify-between"><span class="text-blue-400">Kinetic \(\beta_p\)</span><span id="val-beta">0.000</span></div>
                <div class="flex justify-between"><span class="text-red-400">Potential \(\kappa_p\)</span><span id="val-kappa">0.000</span></div>
            </div>
        </div>

        <div id="panel-contrast" class="p-4 space-y-4 border-b border-gray-800 hidden">
            <div class="text-[9px] uppercase tracking-wider text-green-400 font-bold">Geometric Reconstruction</div>
            <div class="text-gray-500 italic mb-2">Assumes v1 & v2 are Periapsis/Apoapsis extrema.</div>
            <div class="space-y-2">
                <input type="number" id="inp-c-vmax" placeholder="V max (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white focus:border-green-500 outline-none">
                <input type="number" id="inp-c-vmin" placeholder="V min (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white focus:border-green-500 outline-none">
                <button onclick="solveContrast()" class="w-full py-2 bg-green-900/40 border border-green-800 text-green-400 rounded font-bold hover:bg-green-900/60 transition-all">SOLVE GEOMETRY</button>
            </div>
        </div>

        <div id="panel-time" class="p-4 space-y-4 border-b border-gray-800 hidden">
            <div class="text-[9px] uppercase tracking-wider text-purple-400 font-bold">General Orbit Solver</div>
            <div class="text-gray-500 italic mb-2">Finds Min-Eccentricity orbit fitting ANY two velocities & time.</div>
            
            <div class="space-y-2">
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-[9px] text-gray-500">V1 (km/s)</label>
                        <input type="number" id="inp-t-v1" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white focus:border-purple-500 outline-none">
                    </div>
                    <div>
                        <label class="text-[9px] text-gray-500">V2 (km/s)</label>
                        <input type="number" id="inp-t-v2" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white focus:border-purple-500 outline-none">
                    </div>
                </div>
                <div>
                    <label class="text-[9px] text-gray-500">Time Interval (Days)</label>
                    <input type="number" id="inp-t-dt" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white focus:border-purple-500 outline-none">
                </div>
                
                <button onclick="solveTime()" class="w-full py-2 bg-purple-900/40 border border-purple-800 text-purple-300 rounded font-bold hover:bg-purple-900/60 flex justify-center items-center gap-2 transition-all">
                    <span id="loader-time" class="hidden w-3 h-3 border-2 border-purple-300 border-t-transparent rounded-full animate-spin"></span>
                    CALCULATE ORBIT
                </button>
            </div>

            <div id="time-result" class="hidden space-y-2 bg-purple-900/10 p-2 rounded border border-purple-900/30 mt-2">
                <div class="text-[9px] text-purple-400 font-bold border-b border-purple-900/30 pb-1 mb-1">RECONSTRUCTED SYSTEM:</div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Est. Mass:</span> <span id="out-mass" class="text-white font-bold">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Period:</span> <span id="out-period" class="text-white font-bold">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Observed Arc:</span> <span id="out-arc" class="text-white">-</span></div>
            </div>
        </div>

        <div class="p-4 space-y-6 overflow-y-auto flex-1 bg-black/20">
            <div>
                <div class="text-[9px] uppercase tracking-wider text-gray-500 font-bold mb-2">System State</div>
                <div class="space-y-2 font-mono">
                    <div class="flex justify-between items-center bg-gray-900 p-2 rounded border border-gray-800">
                        <span class="text-gray-400">Eccentricity \(e\)</span>
                        <span id="val-e" class="text-white text-lg font-bold">0.000</span>
                    </div>
                    <div class="bg-gray-900 p-2 rounded border border-gray-800">
                        <div class="flex justify-between text-[10px] text-gray-400">
                            <span>Closure (\(\delta\))</span><span id="val-delta">1.00</span>
                        </div>
                        <div class="w-full h-1 bg-gray-800 rounded-full mt-1"><div id="bar-delta" class="h-full bg-blue-500 w-full"></div></div>
                    </div>
                     <div class="flex justify-between items-center px-1">
                        <span class="text-gray-500 text-[10px]">Precession</span>
                        <span id="val-prec" class="text-yellow-600 font-bold text-[10px]">0.00</span>
                    </div>
                </div>
            </div>
            <div id="zone-badge" class="py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-gray-800 text-gray-500 border border-gray-700">-</div>
        </div>
    </div>

    <div class="flex-1 relative bg-black cursor-crosshair overflow-hidden" id="sim-container">
        <canvas id="mainCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        <div class="absolute bottom-4 right-4 bg-black/80 backdrop-blur p-3 rounded border border-gray-800 text-[10px] space-y-2 pointer-events-none">
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-green-500/50 border-t border-dashed border-green-400"></span><span>Circle Line</span></div>
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-red-500/50 border-t border-dashed border-red-400"></span><span>Escape Line</span></div>
             <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-white border-t border-white"></span><span>Observed Arc</span></div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('sim-container');
    const c = 299792.458; 

    // State
    let mode = 'interactive';
    let beta_p = 0.4;
    let kappa_p = 0.4 * Math.sqrt(2);
    let phys = {};
    let dragging = false;
    let width, height, cx, cy, scale;
    let phase = 0;
    
    // Solver Visualization State
    let solvedArc = null; // { o_start, o_end }

    // --- PHYSICS KERNEL ---
    function updatePhysics() {
        const denom = (beta_p * Math.SQRT2);
        const delta = denom > 0.00001 ? kappa_p / denom : 0;
        let e = (delta > 0) ? (1 / (delta * delta)) - 1 : 0;
        
        let status = 'stable';
        let e_real = e;
        
        if (kappa_p < beta_p) { status = 'unbound'; e_real = Math.abs(e); }
        else if (kappa_p > beta_p * Math.SQRT2) { status = 'inverted'; e_real = Math.abs(e); }

        const prec = (3 * Math.PI / 2) * (Math.pow(kappa_p, 4) / Math.pow(beta_p, 2));

        phys = { delta, e, e_real, status, prec };
        updateUI();
    }

    // --- SOLVER 1: CONTRAST (Geometric Extrema) ---
    function solveContrast() {
        solvedArc = null;
        const vmax = parseFloat(document.getElementById('inp-c-vmax').value);
        const vmin = parseFloat(document.getElementById('inp-c-vmin').value);
        if(!vmax || !vmin) return;

        const e_calc = (vmax - vmin) / (vmax + vmin);
        beta_p = vmax / c; 
        kappa_p = beta_p * Math.SQRT2 / Math.sqrt(1 + e_calc);
        updatePhysics();
    }

    // --- SOLVER 2: GENERAL (Time Integral) ---
    function solveTime() {
        solvedArc = null;
        const v1 = parseFloat(document.getElementById('inp-t-v1').value);
        const v2 = parseFloat(document.getElementById('inp-t-v2').value);
        const dt_days = parseFloat(document.getElementById('inp-t-dt').value);
        
        if(!v1 || !v2 || !dt_days) return;

        document.getElementById('loader-time').classList.remove('hidden');
        
        setTimeout(() => {
            // Find Min-Eccentricity Orbit
            const result = findOrbitSolver(v1, v2, dt_days * 86400);
            
            document.getElementById('loader-time').classList.add('hidden');
            document.getElementById('time-result').classList.remove('hidden');
            
            if(result) {
                // Apply visual
                beta_p = result.v_p / c; 
                kappa_p = beta_p * Math.SQRT2 / Math.sqrt(1 + result.e);
                
                // Set arc for drawing
                solvedArc = { start: result.o_start, end: result.o_end };
                
                // Output
                const M_sun = result.M / 1.989e30;
                let m_fmt = M_sun < 0.01 ? M_sun.toExponential(2) : M_sun.toFixed(2);
                document.getElementById('out-mass').innerText = m_fmt + " Mâ˜‰";
                document.getElementById('out-period').innerText = (result.T / 86400).toFixed(1) + " d";
                
                // Phase fraction
                const arcPercent = (Math.abs(result.o_end - result.o_start)/(2*Math.PI)*100).toFixed(1);
                document.getElementById('out-arc').innerText = arcPercent + "% of orbit";
                
                updatePhysics();
            } else {
                alert("No consistent bound orbit found. Data might imply hyperbolic trajectory or inconsistent timing.");
            }
        }, 50);
    }

    // The True Solver Algorithm
    function findOrbitSolver(v1, v2, dt) {
        const v_high = Math.max(v1, v2);
        const v_low = Math.min(v1, v2);
        
        // Min e possible is Contrast e (if v1, v2 were extrema)
        const e_min = (v_high - v_low) / (v_high + v_low);
        
        // Iterate e from e_min upwards to find a fit
        // Step size 0.005
        let bestFit = null;
        let minTimeError = Infinity;

        for(let e = e_min; e < 0.99; e += 0.005) {
            
            // For a given e, ratio v(o1)/v(o2) fixes relative phase.
            // v = V_scale * (1 + e cos o).
            // We assume monotonic arc (o1 to o2).
            // Scan o1 from 0 to PI (symmetric).
            // But we need to check if v2 is reachable.
            
            // Let's deduce Scale from v1: V_scale = v1 / (1 + e cos o1).
            // Then v_calc_2 = V_scale * (1 + e cos o2).
            // We iterate o1.
            
            // Optimization: 
            // The ratio R = v1/v2 = (1+e cos o1)/(1+e cos o2).
            // We can solve o2 given o1.
            
            // Just scan o1
            for(let o1 = 0; o1 < Math.PI; o1 += 0.05) {
                
                // Calculate V_scale assuming this o1 corresponds to v1
                // Note: v1 could be v_high or v_low. Let's strictly map input v1 to o1.
                // But v(o) is symmetric. 
                // Let's assume v1 corresponds to o1.
                // o1=0 is periapsis (Max V).
                
                // Constraint: v(o) must decrease if we move away from 0.
                // If v1 > v2, o1 < o2. 
                // If v1 < v2, o1 > o2 (or approaching periapsis).
                
                // To keep it simple: We map the segment to the "outbound" leg (0 to PI).
                // v_high is at o_near_0. v_low is at o_near_PI.
                
                const ratio = v_low / v_high; 
                // ratio = (1 + e cos o_far) / (1 + e cos o_near).
                
                // Let's verify if o1 (for v_high) works.
                // 1 + e cos o_far = ratio * (1 + e cos o1).
                const term = ratio * (1 + e * Math.cos(o1));
                const cos_o2 = (term - 1) / e;
                
                if(cos_o2 >= -1 && cos_o2 <= 1) {
                    const o2 = Math.acos(cos_o2); // o2 > o1 since v_low < v_high
                    
                    // Now we have candidate phases o1 and o2 for this e.
                    // Calculate Time of Flight using Kepler/WILL Eq.
                    // dt_calc = (M2 - M1) / n.
                    // M = E - e sin E.
                    // tan(E/2) = sqrt((1-e)/(1+e)) tan(o/2).
                    
                    const E1 = 2 * Math.atan(Math.sqrt((1-e)/(1+e)) * Math.tan(o1/2));
                    const E2 = 2 * Math.atan(Math.sqrt((1-e)/(1+e)) * Math.tan(o2/2));
                    
                    const M1 = E1 - e * Math.sin(E1);
                    const M2 = E2 - e * Math.sin(E2);
                    const dM = Math.abs(M2 - M1);
                    
                    // We need 'n' (mean motion).
                    // v(o) = (na / sqrt(1-e^2)) * (1 + e cos o).
                    // So na = v_high * sqrt(1-e^2) / (1 + e cos o1).
                    // Also GM = n^2 a^3.
                    // We need to isolate n? No, we need T or Mass.
                    // Actually, we need to match dt.
                    // We can derive T (and thus dt_calc) from the Scale implied by v_high.
                    // From Vis-Viva/Kepler:
                    // GM = (v * sqrt((1-e)/(1+e)))^3 * T / 2PI ... wait.
                    // Let's use standard unit G=6.674e-11.
                    
                    // Calculate 'a' assuming Mass is unknown? No.
                    // We have v (m/s) and dt (s).
                    // v scales as sqrt(M/a). dt scales as sqrt(a^3/M).
                    // We can solve for M and a uniquely for this geometry.
                    
                    // Let V_geo = (1 + e cos o1) / sqrt(1-e^2).
                    // v_high = sqrt(GM/a) * V_geo.
                    // n = sqrt(GM/a^3).
                    // v_high = n * a * V_geo.
                    // => a = v_high / (n * V_geo).
                    
                    // dt = dM / n => n = dM / dt.
                    
                    // So we know n! 
                    // Now we calculate Mass implied.
                    // a = v_high / ( (dM/dt) * V_geo ).
                    // GM = n^2 * a^3.
                    // M = GM / G.
                    
                    // So for ANY (e, o1), we find a valid Mass.
                    // Which one is "True"?
                    // The user gives just 2 points.
                    // We return the solution with MINIMUM ECCENTRICITY (Occam's Razor).
                    // Since we iterate e from e_min up, the FIRST valid solution found 
                    // is technically the lowest e.
                    
                    // However, we just showed that ANY e > e_min has a solution.
                    // e_min corresponds to o1=0, o2=PI (Contrast limit).
                    // But if dt is very small, e_min -> 0.
                    // If dt is large, e_min holds.
                    
                    // What if the user inputs two v's that are close, but dt is tiny?
                    // Then e_min is small. We find a circular orbit with Mass X.
                    // This is a valid physical solution.
                    
                    // What if the user inputs two v's that are close, but dt is HUGE?
                    // Then e_min is small. Circular orbit. But Period must be huge. Mass huge.
                    
                    // So, returning the Min-Eccentricity solution is the standard "Best Guess".
                    
                    // Calculate Physicals
                    const n_real = dM / dt;
                    const V_geo = (1 + e * Math.cos(o1)) / Math.sqrt(1-e*e);
                    const v_h_m = v_high * 1000;
                    const a_m = v_h_m / (n_real * V_geo);
                    const GM = n_real * n_real * a_m * a_m * a_m;
                    const Mass = GM / 6.6743e-11;
                    const Period = 2 * Math.PI / n_real;
                    
                    // Calculate V_peri for WILL state
                    // v_p = n * a * sqrt((1+e)/(1-e)).
                    const v_p_calc = n_real * a_m * Math.sqrt((1+e)/(1-e)) / 1000;
                    
                    return {
                        e: e,
                        M: Mass,
                        T: Period,
                        v_p: v_p_calc,
                        o_start: o1,
                        o_end: o2
                    };
                }
            }
        }
        return null;
    }

    // --- UI HELPERS ---
    function setMode(m) {
        mode = m;
        ['interactive', 'contrast', 'time'].forEach(k => {
            const pan = document.getElementById('panel-'+k);
            const tab = document.getElementById('tab-'+k);
            if(k === m) {
                pan.classList.remove('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold bg-" + (k==='time'?'purple':(k==='contrast'?'green':'gray')) + "-600 text-white transition-all shadow-[0_0_10px_rgba(255,255,255,0.2)]";
            } else {
                pan.classList.add('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 hover:text-white transition-all";
            }
        });
    }

    function updateUI() {
        document.getElementById('val-beta').innerText = beta_p.toFixed(4);
        document.getElementById('val-kappa').innerText = kappa_p.toFixed(4);
        document.getElementById('val-e').innerText = phys.e.toFixed(4);
        document.getElementById('val-delta').innerText = phys.delta.toFixed(3);
        document.getElementById('val-prec').innerText = phys.prec.toExponential(2);
        
        const badge = document.getElementById('zone-badge');
        const bar = document.getElementById('bar-delta');
        
        if(phys.status === 'unbound') {
            badge.innerText = "UNBOUND";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-red-900/40 text-red-400 border border-red-900";
            bar.className = "h-full bg-red-500 w-full";
        } else if(phys.status === 'inverted') {
            badge.innerText = "INVERTED";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-blue-900/40 text-blue-400 border border-blue-900";
            bar.className = "h-full bg-blue-500 w-full";
        } else {
            badge.innerText = "STABLE";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-green-900/40 text-green-400 border border-green-900";
            bar.className = "h-full bg-green-500 w-full";
        }
    }

    // --- LOOP ---
    function resize() {
        const r = container.getBoundingClientRect();
        width = r.width; height = r.height;
        canvas.width = width; canvas.height = height;
        cx = width/2; cy = height/2;
        scale = Math.min(width, height)/3;
    }
    window.onresize = resize;
    
    function loop() {
        let speed = 0.02 * Math.pow(1 + phys.e_real * Math.cos(phase), 2) / Math.pow(1 + Math.abs(phys.e_real), 2);
        if(speed < 0.001) speed = 0.001;
        phase += speed;
        
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
        ctx.save(); ctx.translate(cx,cy); ctx.scale(1,-1);

        let ds = scale;
        const Q = Math.sqrt(beta_p**2 + kappa_p**2);
        if(Q < 0.1 && Q > 1e-6) ds = scale * (0.4/Q);

        ctx.strokeStyle='#111'; ctx.beginPath();
        for(let i=-10;i<=10;i++) { ctx.moveTo(i*ds,-10*ds); ctx.lineTo(i*ds,10*ds); ctx.moveTo(-10*ds,i*ds); ctx.lineTo(10*ds,i*ds); }
        ctx.stroke();

        ctx.strokeStyle='#333'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,ds,0,7); ctx.stroke();

        ctx.strokeStyle = phys.status==='stable'?'#22c55e':(phys.status==='unbound'?'#ef4444':'#3b82f6');
        ctx.beginPath();
        const p_param = Q * ds * (1 + phys.e_real);
        for(let th=0; th<=360; th+=2) {
            const rad = th*Math.PI/180;
            const r = p_param / (1 + phys.e_real*Math.cos(rad));
            if(r<0 || r>20*ds) continue;
            const x = r*Math.cos(rad); const y = r*Math.sin(rad);
            if(th===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        
        // Draw Solved Arc
        if(solvedArc && phys.status === 'stable') {
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath();
            // Draw arc from start to end
            // Note: Canvas arc is counter-clockwise? Need to handle direction.
            // We'll just draw points.
            let start = solvedArc.start;
            let end = solvedArc.end;
            // Parametric drawing for precision
             for(let th=start; th<=end; th+=0.05) {
                const r = p_param / (1 + phys.e_real*Math.cos(th));
                const x = r*Math.cos(th); const y = r*Math.sin(th);
                if(th===start) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            ctx.lineWidth=2;
        }

        const ra = p_param / (1 + phys.e_real*Math.cos(phase));
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ra*Math.cos(phase), ra*Math.sin(phase), 4, 0, 7); ctx.fill();

        const qx = beta_p * ds; const qy = kappa_p * ds;
        ctx.lineWidth=2; ctx.strokeStyle='#a855f7'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(qx,qy); ctx.stroke();
        ctx.fillStyle=(mode==='interactive')?'#fff':'#9ca3af'; ctx.beginPath(); ctx.arc(qx,qy, 3, 0, 7); ctx.fill();

        ctx.restore();
        requestAnimationFrame(loop);
    }

    resize();
    updatePhysics();
    loop();
</script>