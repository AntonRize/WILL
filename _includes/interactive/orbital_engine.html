<div class="flex flex-col md:flex-row h-[90vh] bg-[#050505] text-gray-300 font-sans text-xs select-none shadow-2xl border border-gray-900 rounded-lg overflow-hidden">

    <div class="w-full md:w-96 bg-gray-900/90 backdrop-blur border-r border-gray-800 flex flex-col z-10 shrink-0 relative">
        
        <div class="p-4 border-b border-gray-800 bg-black">
            <h2 class="text-sm font-bold text-white tracking-widest uppercase flex items-center gap-2 mb-3">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                WILL Relational Engine
            </h2>
            
            <div class="flex bg-gray-800 rounded p-1 gap-1">
                <button onclick="setMode('interactive')" id="tab-interactive" class="flex-1 py-1 px-1 rounded text-[9px] font-bold bg-gray-600 text-white transition-all">MANUAL</button>
                <button onclick="setMode('triangulate')" id="tab-triangulate" class="flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 transition-all">3-POINT NAV</button>
            </div>
        </div>

        <div id="panel-interactive" class="p-4 space-y-4 border-b border-gray-800">
            <div class="text-[9px] uppercase tracking-wider text-blue-400 font-bold">Phase Space Drag</div>
            <div class="space-y-1 font-mono bg-black/30 p-2 rounded border border-gray-800">
                <div class="flex justify-between"><span class="text-blue-400">Kinetic \(\beta_p\)</span><span id="val-beta">0.000</span></div>
                <div class="flex justify-between"><span class="text-red-400">Potential \(\kappa_p\)</span><span id="val-kappa">0.000</span></div>
            </div>
        </div>

        <div id="panel-triangulate" class="p-4 space-y-4 border-b border-gray-800 hidden">
            <div class="text-[9px] uppercase tracking-wider text-purple-400 font-bold">Orbital Triangulation</div>
            <div class="text-gray-500 italic mb-2">Solves Mass & Orbit using acceleration curvature.</div>
            
            <div class="space-y-3 relative">
                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T1</div>
                    <div class="col-span-10"><input type="number" id="v1" placeholder="Velocity 1 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>
                
                <div class="flex justify-center -my-2 z-10 relative"><span class="bg-gray-800 text-[9px] px-2 rounded text-gray-400">Time: <input type="number" id="dt1" class="w-12 bg-black border border-gray-600 text-center text-white" value="10"> days</span></div>

                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T2</div>
                    <div class="col-span-10"><input type="number" id="v2" placeholder="Velocity 2 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>

                <div class="flex justify-center -my-2 z-10 relative"><span class="bg-gray-800 text-[9px] px-2 rounded text-gray-400">Time: <input type="number" id="dt2" class="w-12 bg-black border border-gray-600 text-center text-white" value="10"> days</span></div>

                <div class="grid grid-cols-12 gap-2 items-center bg-gray-900/50 p-1 rounded">
                    <div class="col-span-2 text-center font-bold text-gray-500">T3</div>
                    <div class="col-span-10"><input type="number" id="v3" placeholder="Velocity 3 (km/s)" class="w-full bg-black border border-gray-700 rounded px-2 py-1 text-white text-right font-mono"></div>
                </div>
                
                <button onclick="solveTriangulation()" class="w-full py-3 bg-purple-900/40 border border-purple-800 text-purple-300 rounded font-bold hover:bg-purple-900/60 flex justify-center items-center gap-2 transition-all mt-2">
                    <span id="loader-tri" class="hidden w-3 h-3 border-2 border-purple-300 border-t-transparent rounded-full animate-spin"></span>
                    TRIANGULATE SYSTEM
                </button>
            </div>

            <div id="tri-result" class="hidden space-y-2 bg-purple-900/10 p-2 rounded border border-purple-900/30 mt-2">
                <div class="text-[9px] text-purple-400 font-bold border-b border-purple-900/30 pb-1 mb-1">FOUND SOLUTION:</div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Mass (Mâ˜‰):</span> <span id="out-mass" class="text-white font-bold text-green-400">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Eccentricity:</span> <span id="out-e" class="text-white font-bold text-blue-400">-</span></div>
                <div class="flex justify-between font-mono text-[10px]"><span class="text-gray-400">Period:</span> <span id="out-period" class="text-white">-</span></div>
                <div class="text-[9px] text-gray-500 mt-1 italic text-center">Converged with <span id="out-err">-</span>% error</div>
            </div>
        </div>

        <div class="p-4 space-y-6 overflow-y-auto flex-1 bg-black/20">
            <div>
                <div class="text-[9px] uppercase tracking-wider text-gray-500 font-bold mb-2">System State</div>
                <div class="space-y-2 font-mono">
                    <div class="flex justify-between items-center bg-gray-900 p-2 rounded border border-gray-800">
                        <span class="text-gray-400">Eccentricity \(e\)</span>
                        <span id="val-e" class="text-white text-lg font-bold">0.000</span>
                    </div>
                    <div class="bg-gray-900 p-2 rounded border border-gray-800">
                        <div class="flex justify-between text-[10px] text-gray-400">
                            <span>Closure (\(\delta\))</span><span id="val-delta">1.00</span>
                        </div>
                        <div class="w-full h-1 bg-gray-800 rounded-full mt-1"><div id="bar-delta" class="h-full bg-blue-500 w-full"></div></div>
                    </div>
                </div>
            </div>
            <div id="zone-badge" class="py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-gray-800 text-gray-500 border border-gray-700">-</div>
        </div>
    </div>

    <div class="flex-1 relative bg-black cursor-crosshair overflow-hidden" id="sim-container">
        <canvas id="mainCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        <div class="absolute bottom-4 right-4 bg-black/80 backdrop-blur p-3 rounded border border-gray-800 text-[10px] space-y-2 pointer-events-none">
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-green-500/50 border-t border-dashed border-green-400"></span><span>Circle Line</span></div>
            <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-red-500/50 border-t border-dashed border-red-400"></span><span>Escape Line</span></div>
             <div class="flex items-center gap-2"><span class="w-3 h-0.5 bg-white border-t border-white"></span><span>Observed Arc</span></div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('sim-container');
    const c = 299792.458; 

    // State
    let mode = 'interactive';
    let beta_p = 0.4;
    let kappa_p = 0.4 * Math.sqrt(2);
    let phys = {};
    let dragging = false;
    let width, height, cx, cy, scale;
    let phase = 0;
    
    // Visualization State
    let observedArc = null;

    // --- PHYSICS KERNEL ---
    function updatePhysics() {
        const denom = (beta_p * Math.SQRT2);
        const delta = denom > 0.00001 ? kappa_p / denom : 0;
        let e = (delta > 0) ? (1 / (delta * delta)) - 1 : 0;
        
        let status = 'stable';
        let e_real = e;
        
        if (kappa_p < beta_p) { status = 'unbound'; e_real = Math.abs(e); }
        else if (kappa_p > beta_p * Math.SQRT2) { status = 'inverted'; e_real = Math.abs(e); }

        const prec = (3 * Math.PI / 2) * (Math.pow(kappa_p, 4) / Math.pow(beta_p, 2));

        phys = { delta, e, e_real, status, prec };
        updateUI();
    }

    // --- SOLVER: TRIANGULATION (Robust) ---
    function solveTriangulation() {
        observedArc = null;
        const v1 = parseFloat(document.getElementById('v1').value);
        const v2 = parseFloat(document.getElementById('v2').value);
        const v3 = parseFloat(document.getElementById('v3').value);
        const dt1 = parseFloat(document.getElementById('dt1').value) * 86400; // sec
        const dt2 = parseFloat(document.getElementById('dt2').value) * 86400; // sec
        
        if(!v1 || !v2 || !v3) return;

        document.getElementById('loader-tri').classList.remove('hidden');
        document.getElementById('tri-result').classList.add('hidden');
        
        // Use setTimeout to allow UI to render the loader before heavy calc
        setTimeout(() => {
            try {
                const results = scanIntersection(v1, v2, v3, dt1, dt2);
                
                if(results.best) {
                    const sol = results.best;
                    
                    // Set Global State
                    beta_p = sol.v_p / c; 
                    kappa_p = beta_p * Math.SQRT2 / Math.sqrt(1 + sol.e);
                    
                    // Output
                    const M_sun = sol.M / 1.989e30;
                    let m_fmt = M_sun < 0.01 ? M_sun.toExponential(2) : M_sun.toFixed(2);
                    
                    document.getElementById('out-mass').innerText = m_fmt;
                    document.getElementById('out-e').innerText = sol.e.toFixed(4);
                    document.getElementById('out-period').innerText = (sol.T / 86400).toFixed(1) + " d";
                    document.getElementById('out-err').innerText = (sol.err * 100).toFixed(2);
                    
                    // Visualization
                    observedArc = { start: sol.o1, end: sol.o3 };
                    
                    updatePhysics();
                    document.getElementById('tri-result').classList.remove('hidden');
                } else {
                    alert("No solution found. Check if velocities are consistent with a single orbit.");
                }
            } catch (e) {
                console.error(e);
                alert("Calculation Error: " + e.message);
            } finally {
                document.getElementById('loader-tri').classList.add('hidden');
            }
        }, 100);
    }

    function scanIntersection(v1, v2, v3, dt1, dt2) {
        let bestError = Infinity;
        let bestSol = null;
        
        // Step 1: Scan Eccentricity
        // We scan e from 0.01 to 0.99. 
        for(let e = 0.01; e < 0.99; e += 0.01) {
            
            // Step 2: Scan Phase o1 (From -PI to PI to catch all orbital parts)
            // -PI to 0 = Accelerating (Inbound)
            // 0 to PI = Decelerating (Outbound)
            for(let o1 = -3.1; o1 < 3.1; o1 += 0.1) {
                
                // Solve o2 from Velocity Ratio v1/v2
                // (1 + e cos o1) / (1 + e cos o2) = v1/v2
                const ratio1 = v1 / v2;
                const term2 = (1 + e * Math.cos(o1)) / ratio1;
                const cos_o2 = (term2 - 1) / e;
                
                if(Math.abs(cos_o2) > 1) continue; // Impossible geometry for this e
                
                // Branch check: acos gives positive angle (0..PI). 
                // But o2 could be negative. We check both branches.
                const o2_candidates = [Math.acos(cos_o2), -Math.acos(cos_o2)];

                for(let o2 of o2_candidates) {
                    
                    // Solve o3 from Velocity Ratio v2/v3
                    const ratio2 = v2 / v3;
                    const term3 = (1 + e * Math.cos(o2)) / ratio2;
                    const cos_o3 = (term3 - 1) / e;
                    
                    if(Math.abs(cos_o3) > 1) continue;
                    
                    const o3_candidates = [Math.acos(cos_o3), -Math.acos(cos_o3)];
                    
                    for(let o3 of o3_candidates) {
                        // We now have a candidate triplet (o1, o2, o3)
                        // Check logical consistency: Time must move forward.
                        // We compute Mean Anomalies M1, M2, M3
                        
                        const M1 = getMeanAnomaly(e, o1);
                        const M2 = getMeanAnomaly(e, o2);
                        const M3 = getMeanAnomaly(e, o3);
                        
                        // Handle wrap-around (e.g. passing periapsis 2PI)
                        // dM must be positive.
                        let dM1 = M2 - M1;
                        if(dM1 < 0) dM1 += 2*Math.PI; // Wrap
                        
                        let dM2 = M3 - M2;
                        if(dM2 < 0) dM2 += 2*Math.PI;
                        
                        // Avoid huge jumps (e.g. wrong branch picking 350 degrees orbit)
                        // Assume observations are within one orbit < 2PI
                        if(dM1 > 6 || dM2 > 6) continue; 

                        // CORE CHECK: The Time Ratio must match
                        // (dM1 / dM2) should equal (dt1 / dt2)
                        const dimRatio = dM1 / dM2;
                        const realRatio = dt1 / dt2;
                        
                        const err = Math.abs(dimRatio - realRatio) / realRatio;
                        
                        if(err < 0.05 && err < bestError) {
                            bestError = err;
                            
                            // Calculate Physical Scale from Segment 1
                            const n = dM1 / dt1; // rad/sec
                            // v = n*a / sqrt(1-e^2) * (1+e cos o)
                            // a = v * sqrt(1-e^2) / (n * (1+e cos o))
                            
                            const V_geo = (1 + e * Math.cos(o1)) / Math.sqrt(1-e*e);
                            const v1_m = v1 * 1000;
                            const a = v1_m / (n * V_geo);
                            const GM = n*n * a*a*a;
                            const Mass = GM / 6.6743e-11;
                            
                            // v_p (Periapsis V) for UI
                            const v_p = n * a * Math.sqrt((1+e)/(1-e)) / 1000;
                            
                            bestSol = { e, M: Mass, T: 2*Math.PI/n, v_p, err, o1, o3 };
                        }
                    }
                }
            }
        }
        return { best: bestSol };
    }
    
    function getMeanAnomaly(e, o) {
        // E = 2 atan( sqrt((1-e)/(1+e)) * tan(o/2) )
        const E = 2 * Math.atan(Math.sqrt((1-e)/(1+e)) * Math.tan(o/2));
        // M = E - e sin E
        return E - e * Math.sin(E);
    }

    // --- UI HELPERS ---
    function setMode(m) {
        mode = m;
        ['interactive', 'triangulate'].forEach(k => {
            const pan = document.getElementById('panel-'+k);
            const tab = document.getElementById('tab-'+k);
            if(k === m) {
                pan.classList.remove('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold bg-" + (k==='triangulate'?'purple':'gray') + "-600 text-white transition-all shadow-[0_0_10px_rgba(255,255,255,0.2)]";
            } else {
                pan.classList.add('hidden');
                tab.className = "flex-1 py-1 px-1 rounded text-[9px] font-bold text-gray-400 hover:text-white transition-all";
            }
        });
    }

    function updateUI() {
        document.getElementById('val-beta').innerText = beta_p.toFixed(4);
        document.getElementById('val-kappa').innerText = kappa_p.toFixed(4);
        document.getElementById('val-e').innerText = phys.e.toFixed(4);
        document.getElementById('val-delta').innerText = phys.delta.toFixed(3);
        
        const badge = document.getElementById('zone-badge');
        
        if(phys.status === 'unbound') {
            badge.innerText = "UNBOUND";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-red-900/40 text-red-400 border border-red-900";
        } else if(phys.status === 'inverted') {
            badge.innerText = "INVERTED";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-blue-900/40 text-blue-400 border border-blue-900";
        } else {
            badge.innerText = "STABLE";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] bg-green-900/40 text-green-400 border border-green-900";
        }
    }

    // --- LOOP ---
    function resize() {
        const r = container.getBoundingClientRect();
        width = r.width; height = r.height;
        canvas.width = width; canvas.height = height;
        cx = width/2; cy = height/2;
        scale = Math.min(width, height)/3;
    }
    window.onresize = resize;
    
    function loop() {
        let speed = 0.02 * Math.pow(1 + phys.e_real * Math.cos(phase), 2) / Math.pow(1 + Math.abs(phys.e_real), 2);
        if(speed < 0.001) speed = 0.001;
        phase += speed;
        
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
        ctx.save(); ctx.translate(cx,cy); ctx.scale(1,-1);

        let ds = scale;
        const Q = Math.sqrt(beta_p**2 + kappa_p**2);
        if(Q < 0.1 && Q > 1e-6) ds = scale * (0.4/Q);

        ctx.strokeStyle='#111'; ctx.beginPath();
        for(let i=-10;i<=10;i++) { ctx.moveTo(i*ds,-10*ds); ctx.lineTo(i*ds,10*ds); ctx.moveTo(-10*ds,i*ds); ctx.lineTo(10*ds,i*ds); }
        ctx.stroke();

        ctx.strokeStyle='#333'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,ds,0,7); ctx.stroke();

        ctx.strokeStyle = phys.status==='stable'?'#22c55e':(phys.status==='unbound'?'#ef4444':'#3b82f6');
        ctx.beginPath();
        const p_param = Q * ds * (1 + phys.e_real);
        for(let th=0; th<=360; th+=2) {
            const rad = th*Math.PI/180;
            const r = p_param / (1 + phys.e_real*Math.cos(rad));
            if(r<0 || r>20*ds) continue;
            const x = r*Math.cos(rad); const y = r*Math.sin(rad);
            if(th===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        
        if(observedArc && phys.status === 'stable') {
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath();
            const start = observedArc.start; const end = observedArc.end;
            // Handle wrap-around drawing for arc
            let drawEnd = end;
            if(end < start) drawEnd += 2*Math.PI;
            
            for(let th=start; th<=drawEnd; th+=0.05) {
                const r = p_param / (1 + phys.e_real*Math.cos(th));
                const x = r*Math.cos(th); const y = r*Math.sin(th);
                if(th===start) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            ctx.lineWidth=2;
        }

        const ra = p_param / (1 + phys.e_real*Math.cos(phase));
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(ra*Math.cos(phase), ra*Math.sin(phase), 4, 0, 7); ctx.fill();

        const qx = beta_p * ds; const qy = kappa_p * ds;
        ctx.lineWidth=2; ctx.strokeStyle='#a855f7'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(qx,qy); ctx.stroke();
        ctx.fillStyle=(mode==='interactive')?'#fff':'#9ca3af'; ctx.beginPath(); ctx.arc(qx,qy, 3, 0, 7); ctx.fill();

        ctx.restore();
        requestAnimationFrame(loop);
    }

    resize();
    updatePhysics();
    loop();
</script>