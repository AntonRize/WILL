<div class="flex flex-col md:flex-row h-[85vh] bg-[#050505] text-gray-300 font-sans text-xs select-none">

    <div class="w-full md:w-80 bg-gray-900/80 backdrop-blur border-r border-gray-800 flex flex-col z-10 shrink-0">
        
        <div class="p-4 border-b border-gray-800 bg-gray-950">
            <h2 class="text-sm font-bold text-white tracking-widest uppercase flex items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                WILL Relational Engine
            </h2>
            <div class="text-[10px] text-gray-500 mt-1">Dragging Phase Space \( (\beta, \kappa) \)</div>
        </div>

        <div class="p-4 space-y-6 overflow-y-auto flex-1">
            
            <div>
                <div class="text-[9px] uppercase tracking-wider text-gray-500 font-bold mb-2">Input State (Periapsis)</div>
                <div class="space-y-1 font-mono">
                    <div class="flex justify-between">
                        <span class="text-blue-400">Kinetic \(\beta_p\)</span>
                        <span id="val-beta" class="text-white">0.000</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-red-400">Potential \(\kappa_p\)</span>
                        <span id="val-kappa" class="text-white">0.000</span>
                    </div>
                    <div class="flex justify-between border-t border-gray-800 mt-1 pt-1">
                        <span class="text-purple-400 font-bold">Vector \(Q_p\)</span>
                        <span id="val-q" class="text-white font-bold">0.000</span>
                    </div>
                </div>
            </div>

            <div>
                <div class="text-[9px] uppercase tracking-wider text-gray-500 font-bold mb-2">Geometric Output</div>
                <div class="space-y-2 font-mono">
                    <div class="bg-gray-950 p-2 rounded border border-gray-800">
                        <div class="flex justify-between text-[10px] text-gray-400">
                            <span>Closure (\(\delta\))</span>
                            <span id="val-delta">1.00</span>
                        </div>
                        <div class="w-full h-1 bg-gray-800 rounded-full mt-1 overflow-hidden">
                            <div id="bar-delta" class="h-full bg-green-500 w-full transition-all duration-75"></div>
                        </div>
                    </div>
                    
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">Eccentricity \(e\)</span>
                        <span id="val-e" class="text-white text-lg font-bold">0.00</span>
                    </div>

                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">Precession \(\Delta\varphi\)</span>
                        <div class="text-right">
                            <span id="val-prec" class="text-yellow-500 font-bold block">0.00</span>
                            <span class="text-[9px] text-gray-600">rad/orbit</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="zone-badge" class="py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-green-900/30 text-green-400 border border-green-900 transition-colors">
                Stable Orbit
            </div>

        </div>

        <div class="p-4 border-t border-gray-800 bg-gray-950 space-y-2">
            <div class="text-[9px] uppercase tracking-wider text-gray-500 mb-1">Presets</div>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="setPreset('mercury')" class="px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded text-[10px] transition-colors">Mercury</button>
                <button onclick="setPreset('s2')" class="px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded text-[10px] transition-colors">Star S2</button>
                <button onclick="setPreset('circle')" class="px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded text-[10px] transition-colors">Circle (\(\delta=1\))</button>
                <button onclick="setPreset('critical')" class="px-2 py-1 bg-gray-800 hover:bg-gray-700 rounded text-[10px] transition-colors">Critical (\(e \to 1\))</button>
            </div>
        </div>
    </div>

    <div class="flex-1 relative bg-black cursor-crosshair overflow-hidden" id="sim-container">
        <canvas id="mainCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        
        <div class="absolute bottom-4 right-4 bg-black/60 backdrop-blur p-3 rounded border border-gray-800 text-[10px] space-y-2 pointer-events-none">
            <div class="flex items-center gap-2">
                <span class="w-3 h-0.5 bg-green-500/50 border-t border-dashed border-green-400"></span>
                <span>Circle Line (\(\kappa = \beta\sqrt{2}\))</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="w-3 h-0.5 bg-red-500/50 border-t border-dashed border-red-400"></span>
                <span>Escape Line (\(\kappa = \beta\))</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="w-0 h-0 border-l-[4px] border-l-transparent border-r-[4px] border-r-transparent border-b-[6px] border-b-gray-400"></span>
                <span>Drag \(Q_p\) (Input State)</span>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('sim-container');

    // --- State ---
    // The User controls point Qp (beta_p, kappa_p) directly.
    let beta_p = 0.4;
    let kappa_p = 0.4 * Math.sqrt(2); // Start at perfect circle
    
    let isDragging = false;
    let width, height, scale, cx, cy;
    let phase = 0; // Animation phase

    // --- Physics Engine ---
    function getPhysics() {
        // 1. Fundamental Ratio (Closure Factor)
        // delta = kappa / (beta * sqrt(2))
        // Protect against zero div
        const denom = (beta_p * Math.SQRT2);
        const delta = denom > 0.0001 ? kappa_p / denom : 0;

        // 2. Eccentricity
        // e = 1/delta^2 - 1
        let e = (delta > 0) ? (1 / (delta * delta)) - 1 : 999;
        
        // 3. Zone Logic
        let mode = 'stable'; // stable, inverted, unbound
        let e_real = e;

        // Check boundaries based on y=x and y=sqrt(2)x
        const diagCircle = beta_p * Math.SQRT2;
        const diagEscape = beta_p;

        if (kappa_p < diagEscape) {
            mode = 'unbound';
            e_real = Math.abs(e); // Just for calc
        } else if (kappa_p > diagCircle) {
            mode = 'inverted'; // Apoapsis dominant
            e_real = Math.abs(e); // Flip shape
        }

        // 4. Precession (Geometric)
        // dPhi = 1.5 * PI * (kappa^4 / beta^2)
        const prec = (3 * Math.PI / 2) * (Math.pow(kappa_p, 4) / Math.pow(beta_p, 2));

        // 5. Orbit Visualization Params
        // We define a visual scale 'a' so the orbit fits on screen.
        // r = a(1-e^2) / (1 + e cos theta)
        const a_vis = 1.5; // Visual units

        return { delta, e, e_real, mode, prec, a_vis };
    }

    // --- Interaction ---
    function resize() {
        const rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width;
        canvas.height = height;
        
        cx = width / 2;
        cy = height / 2;
        scale = Math.min(width, height) / 4; // Zoom level
    }
    window.addEventListener('resize', resize);
    
    function getMouse(e) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left - cx) / scale,
            y: -(e.clientY - rect.top - cy) / scale // Flip Y
        };
    }

    canvas.addEventListener('mousedown', e => {
        const m = getMouse(e);
        // Hit test radius 0.2
        const dx = m.x - beta_p;
        const dy = m.y - kappa_p;
        if (dx*dx + dy*dy < 0.04) isDragging = true;
    });

    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const m = getMouse(e);
        // Clamp to positive quadrant for simplicity
        beta_p = Math.max(0.01, m.x);
        kappa_p = Math.max(0.01, m.y);
    });

    window.addEventListener('mouseup', () => isDragging = false);

    // --- Drawing ---
    function draw() {
        // Clear
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(1, -1); // Cartesian coords

        // 1. Grid
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=-10; i<=10; i++) {
            ctx.moveTo(i*scale, -10*scale); ctx.lineTo(i*scale, 10*scale);
            ctx.moveTo(-10*scale, i*scale); ctx.lineTo(10*scale, i*scale);
        }
        ctx.stroke();

        // 2. Critical Lines
        // Green Circle Line (y = x * sqrt(2))
        ctx.strokeStyle = '#064e3b'; // Dark green
        ctx.setLineDash([5, 5]);
        ctx.beginPath(); 
        ctx.moveTo(0,0); 
        ctx.lineTo(3*scale, 3*Math.SQRT2*scale); 
        ctx.stroke();

        // Red Escape Line (y = x)
        ctx.strokeStyle = '#450a0a'; // Dark red
        ctx.beginPath(); 
        ctx.moveTo(0,0); 
        ctx.lineTo(4*scale, 4*scale); 
        ctx.stroke();
        ctx.setLineDash([]);

        // 3. Unit Circle (The Observer's Horizon)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 1*scale, 0, 2*Math.PI);
        ctx.stroke();

        // --- Get Physics State ---
        const phys = getPhysics();

        // 4. Draw Orbit (The Result)
        // We draw the orbit centered on the observer (0,0) is one focus?
        // In WILL, observer is at (0,0). The object moves around.
        // Polar eq: r = p / (1 + e cos theta).
        // p = a(1-e^2). 
        // For visual stability, let's lock periapsis distance r_p.
        // r_p visual = something constant? No, let's fix Semi-Major axis visually
        // to prevent it exploding off screen.
        
        ctx.beginPath();
        if (phys.mode === 'unbound') {
            ctx.strokeStyle = '#ef4444'; // Red orbit
        } else if (phys.mode === 'inverted') {
            ctx.strokeStyle = '#3b82f6'; // Blue orbit (flipped)
        } else {
            ctx.strokeStyle = '#22c55e'; // Green orbit (stable)
        }
        
        ctx.lineWidth = 2;
        
        // Draw ellipse
        // Let's use parametric drawing
        // r(theta) = r_p * (1+e) / (1 + e cos theta)
        // Visually, let's keep r_p somewhat constant relative to input Q
        // so bigger Q = bigger orbit.
        const r_p_vis = Math.sqrt(beta_p*beta_p + kappa_p*kappa_p) * scale; 
        
        // Handling the "Flip":
        // If inverted, r_p is actually Apoapsis.
        // e is negative in the raw formula, which handles the flip automatically!
        // r = p / (1 + e_raw * cos theta)
        
        const p_param = r_p_vis * (1 + phys.e); 

        for (let th = 0; th <= 360; th+=2) {
            const rad = th * Math.PI / 180;
            const r = p_param / (1 + phys.e * Math.cos(rad));
            
            // Limit drawing for unbound
            if (r < 0 || r > 10*scale) continue;

            const ox = r * Math.cos(rad);
            const oy = r * Math.sin(rad);
            
            if (th===0) ctx.moveTo(ox, oy);
            else ctx.lineTo(ox, oy);
        }
        ctx.stroke();

        // 5. Draw The Object (Animation)
        const r_anim = p_param / (1 + phys.e * Math.cos(phase));
        const objX = r_anim * Math.cos(phase);
        const objY = r_anim * Math.sin(phase);

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(objX, objY, 4, 0, 2*Math.PI);
        ctx.fill();
        
        // 6. Draw Vector Qp (The Control Handle)
        const qx = beta_p * scale;
        const qy = kappa_p * scale;

        // Components
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; // Blue beta
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(qx, 0); ctx.stroke();

        ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)'; // Red kappa
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, qy); ctx.stroke();

        // Q Vector
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#a855f7'; // Purple
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(qx, qy); ctx.stroke();

        // The Triangle Handle
        ctx.fillStyle = isDragging ? '#fff' : '#9ca3af';
        ctx.beginPath();
        ctx.moveTo(qx, qy + 8);
        ctx.lineTo(qx + 7, qy - 6);
        ctx.lineTo(qx - 7, qy - 6);
        ctx.fill();

        ctx.restore();

        // --- Update UI Text ---
        document.getElementById('val-beta').innerText = beta_p.toFixed(3);
        document.getElementById('val-kappa').innerText = kappa_p.toFixed(3);
        document.getElementById('val-q').innerText = Math.sqrt(beta_p**2 + kappa_p**2).toFixed(3);
        
        document.getElementById('val-delta').innerText = phys.delta.toFixed(3);
        document.getElementById('val-e').innerText = phys.e.toFixed(3);
        document.getElementById('val-prec').innerText = phys.prec.toExponential(2);
        
        const badge = document.getElementById('zone-badge');
        const bar = document.getElementById('bar-delta');
        
        if (phys.mode === 'unbound') {
            badge.innerText = "UNBOUND (ESCAPE)";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-red-900/30 text-red-400 border border-red-900";
            bar.className = "h-full bg-red-500 w-full";
        } else if (phys.mode === 'inverted') {
            badge.innerText = "INVERTED (APOAPSIS)";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-blue-900/30 text-blue-400 border border-blue-900";
            bar.className = "h-full bg-blue-500 w-full";
        } else {
            badge.innerText = "STABLE ORBIT";
            badge.className = "py-2 px-3 rounded text-center font-bold text-[10px] uppercase bg-green-900/30 text-green-400 border border-green-900";
            bar.className = "h-full bg-green-500 w-full";
        }
    }

    // --- Animation Loop ---
    function loop() {
        // Orbital speed modulation (Kepler 2nd law approx)
        // speed ~ (1 + e cos theta)^2
        const phys = getPhysics();
        let speed = 0.02 * Math.pow(1 + phys.e * Math.cos(phase), 2) / Math.pow(1 + Math.abs(phys.e), 2);
        // Clamp speed for unbound visualization
        if (speed < 0.001) speed = 0.001; 
        
        phase += speed;
        draw();
        requestAnimationFrame(loop);
    }

    // --- Presets ---
    window.setPreset = function(name) {
        if (name === 'mercury') {
            beta_p = 0.4; kappa_p = 0.52; // Exaggerated for visibility
        } else if (name === 's2') {
            beta_p = 0.2; kappa_p = 0.2 * Math.sqrt(2); // High gravity
        } else if (name === 'circle') {
            beta_p = 0.5; kappa_p = 0.5 * Math.SQRT2;
        } else if (name === 'critical') {
            beta_p = 0.5; kappa_p = 0.51; // Near escape
        }
    }

    // Start
    resize();
    loop();

</script>