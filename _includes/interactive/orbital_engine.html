<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<div id="rom-engine-root" style="width: 100%; min-height: 500px; display: flex; justify-content: center; align-items: center; background: #000;">
    <div style="color: #666;">Initializing R.O.M. Kernel...</div>
</div>

<script type="text/babel">
    // --- HOOKS ---
    const { useState, useEffect, useRef } = React;

    // --- CONSTANTS ---
    const G = 6.67430e-11;
    const M_SUN = 1.989e30; 
    const C = 299792458; 

    // --- MAIN COMPONENT ---
    const RomEngine = () => {
        // --- INPUTS ---
        // Defaults set to Golden Ratio (Circle)
        const [kappa, setKappa] = useState(1.414); // sqrt(2) approx
        const [beta, setBeta] = useState(1.000);   // Normalized beta
        const [velocityC, setVelocityC] = useState(0.01); // Real v/c for physical scale
        const [rpPhys, setRpPhys] = useState(1.5e11); // 1 AU approx

        const canvasRef = useRef(null);

        // --- PHYSICS KERNEL ---
        const calculatePhysics = () => {
            // 1. Derivation of shape based on WILL Relations
            // Relation: Circle when kappa = beta * sqrt(2)
            // Escape when kappa = beta
            
            const ratio = kappa / beta; 
            
            // Approximation formula fitting the logic:
            // If ratio = 1.414 (sqrt2) -> e should be 0.
            // If ratio = 1.0 -> e should be 1.
            let e_val = Math.abs( (2 / (ratio * ratio)) - 1 );
            
            // Snap to 0 for circle
            if (e_val < 0.001) e_val = 0;

            const isOpen = e_val >= 1.0;
            const isInverted = ratio < 1.0; // "Below" the escape horizon

            // 2. Physical derived values
            // Mass derived from Vis-Viva at periapsis: v = sqrt(GM(1+e)/rp)
            // M = (v^2 * rp) / (G * (1 + e))
            const v = velocityC * C;
            const mass_kg = (v * v * rpPhys) / (G * (1 + e_val));
            
            // Q Vector (Magnitude)
            const Q = Math.sqrt(kappa**2 + beta**2);

            return { e: e_val, isOpen, isInverted, mass_kg, Q };
        };

        const physics = calculatePhysics();

        // --- VISUALIZATION KERNEL (Normalized a=1) ---
        useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            // High DPI fix
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const cx = width / 2;
            const cy = height / 2;

            // Clear
            ctx.fillStyle = '#050505';
            ctx.fillRect(0,0, width, height);
            
            // Grid
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx, 0); ctx.lineTo(cx, height);
            ctx.moveTo(0, cy); ctx.lineTo(width, cy);
            ctx.stroke();

            // --- DRAWING CONFIG ---
            // "Hard Normalization": a = 1.
            // We map a=1 to a fixed pixel size.
            let PIXELS_per_A = Math.min(width, height) * 0.25;
            
            if (physics.isOpen) PIXELS_per_A *= 0.6;

            ctx.beginPath();
            ctx.lineWidth = 2;
            
            // Color Logic
            if (physics.isOpen) ctx.strokeStyle = '#FF4444'; // Red (Escape)
            else if (physics.e < 0.05) ctx.strokeStyle = '#00FF88'; // Green (Circle)
            else ctx.strokeStyle = '#00F0FF'; // Cyan (Orbit)

            // Geometry Generation
            const steps = 500;
            let startTheta = 0;
            let endTheta = 2 * Math.PI;

            // Hyperbola limits
            if (physics.isOpen) {
                const limit = Math.acos(-1 / physics.e);
                startTheta = -limit + 0.1;
                endTheta = limit - 0.1;
            }

            let firstPoint = true;

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const theta = startTheta + (endTheta - startTheta) * t;

                // POLAR EQUATION (a=1)
                // r = |1 - e^2| / (1 + e cos(theta))
                const numerator = Math.abs(1 - physics.e**2);
                const r_norm = numerator / (1 + physics.e * Math.cos(theta));
                
                const r_pix = r_norm * PIXELS_per_A;

                let x = r_pix * Math.cos(theta);
                let y = r_pix * Math.sin(theta);

                // Inversion logic
                if (physics.isInverted) { x = -x; y = -y; }

                if (firstPoint) {
                    ctx.moveTo(cx + x, cy - y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(cx + x, cy - y);
                }
            }
            ctx.stroke();

            // Draw Focus (Singularity)
            ctx.beginPath();
            ctx.fillStyle = '#FFF';
            ctx.arc(cx, cy, 3, 0, Math.PI*2);
            ctx.fill();

            // Draw "Triangle" visualization (Bottom Right)
            const tx = width - 60;
            const ty = height - 60;
            const scaleT = 40;
            
            // Beta Leg (Horizontal)
            ctx.strokeStyle = '#666'; ctx.beginPath();
            ctx.moveTo(tx, ty); ctx.lineTo(tx + beta*scaleT, ty); ctx.stroke();
            
            // Kappa Leg (Vertical)
            ctx.strokeStyle = '#666'; ctx.beginPath();
            ctx.moveTo(tx, ty); ctx.lineTo(tx, ty - kappa*scaleT); ctx.stroke();
            
            // Q (Hypotenuse)
            ctx.strokeStyle = '#FF0055'; ctx.beginPath();
            ctx.moveTo(tx + beta*scaleT, ty); ctx.lineTo(tx, ty - kappa*scaleT); ctx.stroke();

        }, [kappa, beta, physics]);

        return (
            <div style={{ fontFamily: 'monospace', background: '#000', border: '1px solid #333', padding: '20px', borderRadius: '8px' }}>
                
                {/* HEADER */}
                <div style={{display:'flex', justifyContent:'space-between', alignItems:'flex-end', marginBottom:'20px', borderBottom:'1px solid #333', paddingBottom:'10px'}}>
                    <div>
                        <h2 style={{margin:0, color:'#fff', fontSize:'20px'}}>R.O.M. <span style={{color:'#FF0055'}}>ENGINE</span></h2>
                        <div style={{fontSize:'10px', color:'#666'}}>RELATIONAL ORBITAL MECHANICS</div>
                    </div>
                    <div style={{textAlign:'right'}}>
                        <div style={{fontSize:'12px', color: physics.isOpen ? '#FF4444' : '#00F0FF'}}>
                            {physics.isOpen ? 'UNBOUND / ESCAPE' : 'STABLE CYCLIC'}
                        </div>
                        <div style={{fontSize:'10px', color:'#888'}}>
                            e = {physics.e.toFixed(4)}
                        </div>
                    </div>
                </div>

                {/* GRID */}
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '20px' }}>
                    
                    {/* CONTROLS */}
                    <div style={{display:'flex', flexDirection:'column', gap:'20px'}}>
                        
                        {/* INPUT BLOCK 1: SHAPE */}
                        <div style={{background:'#0a0a0a', padding:'15px', borderRadius:'4px', border:'1px solid #222'}}>
                            <div style={{color:'#888', fontSize:'10px', marginBottom:'10px', textTransform:'uppercase'}}>Shape Determinants</div>
                            
                            <label style={{display:'flex', justifyContent:'space-between', color:'#ccc', fontSize:'12px'}}>
                                <span>Grav. Potential (κ)</span>
                                <span style={{color:'#FF0055'}}>{kappa.toFixed(3)}</span>
                            </label>
                            <input 
                                type="range" min="0.5" max="3.0" step="0.01"
                                value={kappa} onChange={(e) => setKappa(parseFloat(e.target.value))}
                                style={{width:'100%', marginBottom:'10px'}}
                            />

                            <label style={{display:'flex', justifyContent:'space-between', color:'#ccc', fontSize:'12px'}}>
                                <span>Ref. Velocity (β)</span>
                                <span style={{color:'#00F0FF'}}>{beta.toFixed(3)}</span>
                            </label>
                            <input 
                                type="range" min="0.5" max="3.0" step="0.01"
                                value={beta} onChange={(e) => setBeta(parseFloat(e.target.value))}
                                style={{width:'100%'}}
                            />
                            
                            <div style={{marginTop:'10px', fontSize:'10px', color:'#555', fontStyle:'italic'}}>
                                κ = β√2 creates Circles.
                            </div>
                        </div>

                        {/* INPUT BLOCK 2: SCALE */}
                        <div style={{background:'#0a0a0a', padding:'15px', borderRadius:'4px', border:'1px solid #222'}}>
                            <div style={{color:'#888', fontSize:'10px', marginBottom:'10px', textTransform:'uppercase'}}>Physical Scale</div>
                            
                            <label style={{display:'flex', justifyContent:'space-between', color:'#ccc', fontSize:'12px'}}>
                                <span>Velocity v/c</span>
                                <span>{velocityC.toFixed(4)}</span>
                            </label>
                            <input 
                                type="range" min="0.0001" max="0.1" step="0.0001"
                                value={velocityC} onChange={(e) => setVelocityC(parseFloat(e.target.value))}
                                style={{width:'100%', marginBottom:'10px'}}
                            />

                            <label style={{display:'block', color:'#ccc', fontSize:'12px', marginBottom:'5px'}}>Periapsis Radius (m)</label>
                            <input 
                                type="number" 
                                value={rpPhys} onChange={(e) => setRpPhys(parseFloat(e.target.value))}
                                style={{width:'100%', background:'#111', border:'1px solid #333', color:'#fff', padding:'4px'}}
                            />
                        </div>

                        {/* OUTPUTS */}
                        <div style={{borderLeft:'2px solid #fff', paddingLeft:'10px'}}>
                            <div style={{fontSize:'10px', color:'#666'}}>DERIVED MASS</div>
                            <div style={{fontSize:'16px', color:'#fff'}}>{physics.mass_kg.toExponential(3)} kg</div>
                            <div style={{fontSize:'12px', color:'#FFD700'}}>≈ {(physics.mass_kg / M_SUN).toFixed(2)} M☉</div>
                        </div>

                    </div>

                    {/* CANVAS AREA */}
                    <div style={{position:'relative', border:'1px solid #222', borderRadius:'4px', overflow:'hidden', height:'400px'}}>
                        <canvas ref={canvasRef} style={{width:'100%', height:'100%', display:'block'}} />
                        
                        <div style={{position:'absolute', bottom:10, left:10, fontSize:'10px', color:'#444'}}>
                            NORMALIZED VIEW (a=1)
                        </div>
                    </div>

                </div>
            </div>
        );
    };

    // --- MOUNTING ---
    const rootElement = document.getElementById('rom-engine-root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(<RomEngine />);
</script>