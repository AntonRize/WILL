<div id="gd-overall-median-inline" class="mt-4 text-cyan-200 font-semibold"></div>

<div id="gd-type-filter" class="bg-gray-800/50 p-6 rounded-lg mb-6 border border-gray-700 shadow-lg">
  <div class="flex flex-wrap justify-between items-end gap-6">
    <div class="flex-1">
      <h4 class="text-lg font-bold text-gray-200 mb-3 flex items-center">
        <svg class="w-5 h-5 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path></svg>
        Filter by Hubble Type
      </h4>
      <div id="gd-type-checkboxes" class="flex flex-wrap gap-3 text-gray-300"></div>
    </div>
    
    <div class="bg-gray-900/60 p-4 rounded-lg border border-gray-600">
      <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-2">Analysis Metric</span>
      <div class="flex space-x-4">
        <label class="flex items-center cursor-pointer group">
          <input type="radio" name="analysis-metric" value="rmse" checked class="form-radio text-blue-500 bg-gray-700 border-gray-500 focus:ring-blue-500">
          <span class="ml-2 text-gray-200 group-hover:text-white transition">RMSE</span>
        </label>
        <label class="flex items-center cursor-pointer group">
          <input type="radio" name="analysis-metric" value="chi2" class="form-radio text-purple-500 bg-gray-700 border-gray-500 focus:ring-purple-500">
          <span class="ml-2 text-gray-200 group-hover:text-white transition">Reduced χ²</span>
        </label>
      </div>
    </div>
  </div>
  
  <button id="gd-analyze-types-btn" class="mt-6 px-6 py-2.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-lg shadow-md transition-all transform hover:scale-105 w-full md:w-auto flex items-center justify-center">
    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
    Analyze Distribution
  </button>
</div>

<div id="gd-type-plot" class="bg-gray-800/50 p-4 rounded-lg mb-6 border border-gray-700" style="display:none">
  <div id="gd-overall-median" class="text-gray-200 font-semibold mb-3 text-lg border-b border-gray-700 pb-2"></div>
  <div id="gd-rmse-histogram"></div>
</div>

<div class="calculator-container bg-gray-800/50 p-6 rounded-lg border border-gray-700 shadow-xl">
  <div id="gd-loader" class="text-center text-blue-300 animate-pulse font-bold text-xl py-10">Loading SPARC Database...</div>

  <div id="gd-calculator-body" style="display:none">
    
    <div class="controls-grid grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
      <div class="control-group">
        <label for="gd-galaxy-select" class="block text-gray-300 font-bold mb-2">Select Galaxy:</label>
        <select id="gd-galaxy-select" class="form-control w-full bg-gray-700 text-white border border-gray-600 rounded p-2 focus:ring-2 focus:ring-blue-500"></select>
        
        <div id="gd-galaxy-info" class="mt-4 bg-gray-900/50 p-4 rounded border border-gray-600 text-sm text-gray-300 grid grid-cols-2 gap-y-2"></div>
      </div>

      <div class="control-group bg-gray-900/40 p-5 rounded-lg border border-gray-600 relative overflow-hidden">
        <div class="absolute top-0 right-0 p-2 opacity-10">
          <svg class="w-24 h-24 text-white" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a8 8 0 100 16 8 8 0 000-16zM4 10a6 6 0 1112 0 6 6 0 01-12 0z"/></svg>
        </div>
        
        <div class="flex justify-between items-center mb-6 border-b border-gray-600 pb-3 relative z-10">
          <span class="text-gray-100 font-bold text-lg">Mass-to-Light (Υ)</span>
          <label class="flex items-center space-x-2 cursor-pointer bg-gray-700 px-3 py-1.5 rounded-full border border-gray-500 hover:bg-gray-600 transition shadow-sm">
            <input type="checkbox" id="gd-autofit-check" class="form-checkbox text-blue-500 rounded focus:ring-0">
            <span class="text-sm font-bold text-blue-300">Auto-fit</span>
          </label>
        </div>

        <div class="relative z-10 space-y-5">
          <div>
            <div class="flex justify-between text-sm mb-1 font-medium">
              <label for="gd-ydisk-slider" class="text-blue-200">Disk (Υ<sub>disk</sub>)</label>
              <span id="gd-ydisk-value" class="text-cyan-400 font-mono">0.50</span>
            </div>
            <input type="range" id="gd-ydisk-slider" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" min="0.05" max="3.00" step="0.01" value="0.50" />
          </div>

          <div>
            <div class="flex justify-between text-sm mb-1 font-medium">
              <label for="gd-ybulge-slider" class="text-yellow-200">Bulge (Υ<sub>bulge</sub>)</label>
              <span id="gd-ybulge-value" class="text-cyan-400 font-mono">0.70</span>
            </div>
            <input type="range" id="gd-ybulge-slider" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500" min="0.05" max="3.00" step="0.01" value="0.70" />
          </div>
        </div>
      </div>
    </div>

    <div id="gd-results" class="grid grid-cols-2 gap-6 mb-8">
      <div class="bg-gradient-to-br from-gray-800 to-gray-700 border border-gray-600 rounded-lg p-4 text-center shadow-lg relative overflow-hidden group hover:border-blue-500 transition">
        <div class="absolute top-0 right-0 w-16 h-16 bg-white opacity-5 rounded-full -mr-8 -mt-8"></div>
        <div class="text-gray-400 text-xs font-bold uppercase tracking-widest mb-1">RMSE</div>
        <div class="text-4xl font-black text-white tracking-tight group-hover:text-blue-400 transition" id="res-rmse">--</div>
        <div class="text-xs text-gray-500 mt-1 font-mono">km/s</div>
      </div>
      <div class="bg-gradient-to-br from-gray-800 to-gray-700 border border-gray-600 rounded-lg p-4 text-center shadow-lg relative overflow-hidden group hover:border-purple-500 transition">
        <div class="absolute top-0 right-0 w-16 h-16 bg-white opacity-5 rounded-full -mr-8 -mt-8"></div>
        <div class="text-gray-400 text-xs font-bold uppercase tracking-widest mb-1">Reduced χ²</div>
        <div class="text-4xl font-black text-purple-300 tracking-tight group-hover:text-purple-200 transition" id="res-chi">--</div>
        <div class="text-xs text-gray-500 mt-1 font-mono">Target ~ 1.0</div>
      </div>
    </div>
    
    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
      <div class="bg-gray-900 rounded-lg border border-gray-700 p-2 shadow-inner h-[500px]">
        <div id="gd-plot-div" class="w-full h-full"></div>
      </div>
      <div class="bg-gray-900 rounded-lg border border-gray-700 p-2 shadow-inner h-[500px]">
        <div id="gd-plot-div-components" class="w-full h-full"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<script>
{ // Scope isolation
  
  /* CONFIG & GLOBALS */
  const RAW_BASE = "https://raw.githubusercontent.com/AntonRize/WILL/main/SPARC%20DATA/";
  const URL_TABLE1 = RAW_BASE + "table1.dat";
  const URL_TABLE2 = RAW_BASE + "table2.dat";

  let galaxyData = {};
  let galaxyMeta = {};
  let distinctTypes = [];
  const hubbleTypes = ["S0","Sa","Sab","Sb","Sbc","Sc","Scd","Sd","Sdm","Sm","Im","BCD"];

  // PHYSICS CONSTANTS
  const H0 = 65.5; 
  const MPC_TO_M = 3.086e22; 
  const KPC_TO_M = 3.086e19; 
  const H0_SI = (H0 * 1000) / MPC_TO_M;
  const C_LIGHT_KMS = 299792.458; 
  const C_SI = C_LIGHT_KMS * 1000;
  const A_VAC_SI = (C_SI * H0_SI) / (2 * Math.PI); 

  /* DOM Elements */
  const loader = document.getElementById("gd-loader");
  const bodyEl = document.getElementById("gd-calculator-body");
  const galaxySelect = document.getElementById("gd-galaxy-select");
  
  // Sliders & Checkbox
  const yDiskSlider = document.getElementById("gd-ydisk-slider");
  const yBulgeSlider = document.getElementById("gd-ybulge-slider");
  const yDiskDisplay = document.getElementById("gd-ydisk-value");
  const yBulgeDisplay = document.getElementById("gd-ybulge-value");
  const autofitCheck = document.getElementById("gd-autofit-check");

  // Output
  const resRmse = document.getElementById("res-rmse");
  const resChi = document.getElementById("res-chi");
  const plotDiv = document.getElementById("gd-plot-div");
  const plotDivComponents = document.getElementById("gd-plot-div-components");
  const galaxyInfoDiv = document.getElementById("gd-galaxy-info");

  /* --- DATA LOADING --- */
  async function loadData(){
    try{
      if(!window.Plotly) throw new Error("Plotly failed to load.");
      const [t1Res,t2Res]=await Promise.all([fetch(URL_TABLE1),fetch(URL_TABLE2)]);
      if(!t1Res.ok||!t2Res.ok) throw new Error("Failed to fetch SPARC tables.");

      const t1Text=await t1Res.text();
      const t2Text=await t2Res.text();

      // Parse Table 1 (Metadata)
      const typeSet = new Set();
      t1Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const name=line.substring(0,11).trim();
        const rest=line.substring(11).trim().split(/\s+/);
        if(rest.length<18) return;
        
        galaxyMeta[name]={
          Name:name,
          Rdisk: +rest[10], 
          Dist:+rest[1], 
          L36:+rest[6],
          TypeRaw:rest[0]
        };
        const typeId = parseInt(rest[0],10);
        const typeLabel = (hubbleTypes[typeId]!==undefined) ? hubbleTypes[typeId] : String(rest[0]);
        galaxyMeta[name].TypeLabel = typeLabel;
        typeSet.add(typeLabel);
      });
      distinctTypes = Array.from(typeSet).sort();

      // Parse Table 2 (Velocities)
      t2Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const p=line.trim().split(/\s+/);
        if(p.length<8) return;
        
        const row={ 
          Name:p[0], Dist:+p[1], Rad:+p[2], 
          Vobs:+p[3], Verr:+p[4], 
          Vgas:+p[5], Vdisk:+p[6], Vbul:+p[7] 
        };
        (galaxyData[row.Name] ||= []).push(row);
      });

      // Populate Select
      Object.keys(galaxyData).sort().forEach(name=>{
        if(galaxyData[name].length<3) return;
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name; galaxySelect.appendChild(opt);
      });
      
      initGalaxyTypeCheckboxes();
      loader.style.display="none"; bodyEl.style.display="block";
      
      // Initial State
      galaxySelect.selectedIndex=0;
      updateGalaxyInfo();
      updateAll();
      
    }catch(err){
      loader.textContent = "Error: " + err.message;
      console.error(err);
    }
  }

  /* --- PHYSICS CORE: WILL FORMULA --- */
  function seriesQWILL(galaxyName, yDisk, yBulge){
    const data = (galaxyData[galaxyName]||[]).slice().sort((a,b)=>a.Rad-b.Rad);
    const r = [], Vobs = [], Verr = [], Vbary = [], Vq = [];
    const Vgas_comp = [], Vdisk_scaled = [], Vbulge_scaled = [];

    for(const d of data){
      const vo = (Number.isFinite(d.Vobs) && d.Vobs >= 0) ? d.Vobs : NaN;
      if(!Number.isFinite(vo)) continue;

      const vg = d.Vgas > 0 ? d.Vgas : 0;
      const vd = d.Vdisk > 0 ? d.Vdisk : 0;
      const vb = d.Vbul > 0 ? d.Vbul : 0;

      // 1. Baryonic Velocity (Separate Disks & Bulge M/L)
      const vbary2 = vg*vg + yDisk * (vd*vd) + yBulge * (vb*vb);
      const vbary  = Math.sqrt(Math.max(0, vbary2));
      
      // 2. WILL Vacuum Screening
      let chi = 0;
      if (d.Rad > 0) {
        const g_bar = (vbary * 1000)**2 / (d.Rad * KPC_TO_M);
        chi = g_bar / A_VAC_SI;
      } else {
        chi = 1e6; // Infinite acceleration at center -> Newtonian
      }
      
      // 3. WILL Prediction
      const factor = Math.sqrt(1 + 2 * Math.exp(-chi));
      const vq = vbary * factor;

      // 4. Error Handling
      let obsErr = (Number.isFinite(d.Verr) && d.Verr > 0) ? d.Verr : 0;
      let sigma = Math.max(obsErr, 5.0, Math.abs(vo) * 0.05);

      r.push(d.Rad);
      Vobs.push(vo);
      Verr.push(sigma); 
      Vbary.push(vbary);
      Vq.push(vq);
      
      Vgas_comp.push(vg);
      Vdisk_scaled.push(Math.sqrt(yDisk) * vd);
      Vbulge_scaled.push(Math.sqrt(yBulge) * vb);
    }
    return { r, Vobs, Verr, Vbary, Vq, components: { Vgas: Vgas_comp, Vdisk_scaled, Vbulge_scaled } };
  }

  /* --- 2-PARAMETER OPTIMIZATION (Coordinate Descent) --- */
  function optimizeTwoParams(galaxyName) {
    let bestDisk = 0.5;
    let bestBulge = 0.7;
    let minErr = Infinity;

    const scan = (isDiskScanning) => {
      let localBest = isDiskScanning ? bestDisk : bestBulge;
      let localMin = minErr;
      
      for(let val = 0.05; val <= 2.5; val += 0.1) {
        const d = isDiskScanning ? val : bestDisk;
        const b = isDiskScanning ? bestBulge : val;
        const S = seriesQWILL(galaxyName, d, b);
        const err = calculateRMSE(S.Vobs, S.Vq);
        if(isFinite(err) && err < localMin) { localMin = err; localBest = val; }
      }
      // Fine tune
      let start = Math.max(0.01, localBest - 0.1);
      let end = localBest + 0.1;
      for(let val = start; val <= end; val += 0.01) {
        const d = isDiskScanning ? val : bestDisk;
        const b = isDiskScanning ? bestBulge : val;
        const S = seriesQWILL(galaxyName, d, b);
        const err = calculateRMSE(S.Vobs, S.Vq);
        if(isFinite(err) && err < localMin) { localMin = err; localBest = val; }
      }
      return { val: localBest, err: localMin };
    };

    // Pass 1: Disk
    let res = scan(true); bestDisk = res.val; minErr = res.err;
    // Pass 2: Bulge
    res = scan(false); bestBulge = res.val; minErr = res.err;
    // Pass 3: Disk Refine
    res = scan(true); bestDisk = res.val; minErr = res.err;

    return { yDisk: bestDisk, yBulge: bestBulge };
  }

  /* --- METRICS & UTILS --- */
  function calculateRMSE(obs, pred){
    let s=0, k=0;
    for(let i=0;i<Math.min(obs.length,pred.length);i++){
      if(Number.isFinite(obs[i]) && Number.isFinite(pred[i])){ s+=(obs[i]-pred[i])**2; k++; }
    }
    return k>0 ? Math.sqrt(s/k) : NaN;
  }

  function calculateReducedChi2(obs, pred, err, freeParams){
    let s=0, k=0;
    for(let i=0;i<Math.min(obs.length,pred.length);i++){
      if(Number.isFinite(obs[i]) && Number.isFinite(pred[i]) && Number.isFinite(err[i])){ 
        s += ((obs[i]-pred[i]) / err[i])**2; 
        k++; 
      }
    }
    const dof = k - freeParams;
    return dof > 0 ? s/dof : NaN;
  }

  /* --- UI UPDATES --- */
  function updateAll(){
    const name = galaxySelect.value; if(!name) return;
    const isAuto = autofitCheck.checked;
    
    if (isAuto) {
      yDiskSlider.disabled = true; yBulgeSlider.disabled = true;
      yDiskSlider.parentElement.parentElement.classList.add("opacity-50", "pointer-events-none");
    } else {
      yDiskSlider.disabled = false; yBulgeSlider.disabled = false;
      yDiskSlider.parentElement.parentElement.classList.remove("opacity-50", "pointer-events-none");
    }

    let yDisk = 0.5, yBulge = 0.7;

    if (isAuto) {
      const best = optimizeTwoParams(name);
      yDisk = best.yDisk; yBulge = best.yBulge;
      yDiskDisplay.textContent = yDisk.toFixed(2) + " (Auto)";
      yBulgeDisplay.textContent = yBulge.toFixed(2) + " (Auto)";
    } else {
      yDisk = +yDiskSlider.value;
      yBulge = +yBulgeSlider.value;
      yDiskDisplay.textContent = yDisk.toFixed(2);
      yBulgeDisplay.textContent = yBulge.toFixed(2);
    }

    const S = seriesQWILL(name, yDisk, yBulge);
    const R = calculateRMSE(S.Vobs, S.Vq);
    const k_param = isAuto ? 2 : 0; 
    const Chi = calculateReducedChi2(S.Vobs, S.Vq, S.Verr, k_param);

    resRmse.textContent = isFinite(R) ? R.toFixed(2) : "—";
    resChi.textContent = isFinite(Chi) ? Chi.toFixed(2) : "—";
    
    drawPlots(name, S);
  }

  function drawPlots(name, S){
    if(!window.Plotly) return;
    const ymax = Math.max(1, ...S.Vobs, ...S.Vq);
    const layoutBase = {
      xaxis:{ title:"r (kpc)", color:"#9ca3af", gridcolor:"#374151" },
      yaxis:{ title:"Velocity (km/s)", color:"#9ca3af", gridcolor:"#374151", range:[0, ymax*1.1] },
      legend:{ orientation:"h", y:1.1, bgcolor:"transparent", font:{color:"#d1d5db"} },
      margin:{ l:50, r:20, b:40, t:50 },
      paper_bgcolor:"transparent", plot_bgcolor:"transparent", font:{ color:"#d1d5db" }
    };

    Plotly.react(plotDiv, [
      { x:S.r, y:S.Vobs, error_y:{ type:'data', array:S.Verr, visible:true, color:'#6b7280' }, mode:"markers", name:"Observed", marker:{ color:"#d1d5db", size:6 }},
      { x:S.r, y:S.Vbary, mode:"lines", name:"Baryonic (Newton)", line:{ color:"#9ca3af", dash:"dash" }},
      { x:S.r, y:S.Vq, mode:"lines", name:"WILL Predicted", line:{ color:"#67e8f9", width:3 }}
    ], { ...layoutBase, title:`Rotation Curve: ${name}` });

    Plotly.react(plotDivComponents, [
      { x:S.r, y:S.Vobs, mode:"markers", name:"Observed", marker:{ color:"#6b7280", size:5, symbol:"circle-open" }},
      { x:S.r, y:S.components.Vgas, mode:"lines", name:"Gas", line:{ color:"#10b981" }},
      { x:S.r, y:S.components.Vdisk_scaled, mode:"lines", name:"Disk", line:{ color:"#3b82f6" }},
      { x:S.r, y:S.components.Vbulge_scaled, mode:"lines", name:"Bulge", line:{ color:"#f59e0b" }}
    ], { ...layoutBase, title:`Components Breakdown` });
  }

  function updateGalaxyInfo(){
     const meta=galaxyMeta[galaxySelect.value]; if(!meta) return;
     galaxyInfoDiv.innerHTML = `
       <div><span class="text-gray-500">Type:</span> <span class="font-bold text-white">${meta.TypeLabel}</span></div>
       <div><span class="text-gray-500">Dist:</span> <span class="font-bold text-white">${meta.Dist} Mpc</span></div>
       <div><span class="text-gray-500">Lum:</span> <span class="font-bold text-white">${meta.L36} G L&#9737;</span></div>
       <div><span class="text-gray-500">R_disk:</span> <span class="font-bold text-white">${meta.Rdisk} kpc</span></div>
     `;
  }

  /* --- GROUP ANALYSIS (Optimized & Linked) --- */
  function analyzeSelectedTypes(){
    const btn = document.getElementById("gd-analyze-types-btn");
    btn.textContent = "Calculating..."; btn.disabled = true;

    setTimeout(() => {
      const selected = Array.from(document.querySelectorAll("#gd-type-checkboxes input:checked")).map(cb=>cb.value);
      if(!selected.length){ alert("Select types."); btn.textContent="Analyze Distribution"; btn.disabled=false; return; }
      
      const isAuto = autofitCheck.checked;
      const fixedDisk = +yDiskSlider.value;
      const fixedBulge = +yBulgeSlider.value;
      const metricRadio = document.querySelector('input[name="analysis-metric"]:checked');
      const mode = metricRadio ? metricRadio.value : 'rmse'; 

      const metricValues=[];
      
      for(const name in galaxyData){
        const meta=galaxyMeta[name]; if(!meta) continue;
        if(!selected.includes(meta.TypeLabel)) continue;
        
        let yD = fixedDisk, yB = fixedBulge;
        if(isAuto){
          const best = optimizeTwoParams(name);
          yD = best.yDisk; yB = best.yBulge;
        }
        
        const S = seriesQWILL(name, yD, yB);
        if(S.Vobs.length > 0){
          let val = (mode==='rmse') 
            ? calculateRMSE(S.Vobs, S.Vq)
            : calculateReducedChi2(S.Vobs, S.Vq, S.Verr, isAuto?2:0);
          
          if(Number.isFinite(val) && val < 500) metricValues.push(val);
        }
      }
      
      plotHistogram(metricValues, mode, isAuto, fixedDisk, fixedBulge);
      btn.textContent = "Analyze Distribution"; btn.disabled = false;
    }, 50);
  }

  function plotHistogram(values, mode, isAuto, fd, fb){
    if(!values.length) return;
    const sorted = values.slice().sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const label = mode==='rmse'?"RMSE":"Reduced χ²";
    const modeTxt = isAuto ? "(Auto-fitted Υ)" : `(Fixed: D=${fd}, B=${fb})`;

    document.getElementById("gd-overall-median").innerHTML = 
      `Metric: <span class="text-blue-400">${label}</span> — N=${values.length} — <span class="text-green-400">Median: ${median.toFixed(2)}</span> <span class="text-gray-500 text-sm ml-2">${modeTxt}</span>`;

    // Concise Binning Logic (Replaces buildHistogramData)
    const maxVal = Math.min(Math.max(...values), mode==='rmse'?100:20);
    const binCount = 25;
    const binSize = maxVal/binCount;
    const x = [], y = new Array(binCount).fill(0);
    
    for(let i=0; i<binCount; i++) x.push(i*binSize + binSize/2);
    values.forEach(v => {
      let idx = Math.floor(v/binSize);
      if(idx >= binCount) idx = binCount-1;
      if(idx >=0) y[idx]++;
    });

    const trace = { type: "bar", x: x, y: y, marker: { color: "#67e8f9", line: {color:"#1f2937", width:1} } };
    const layout = {
      xaxis:{ title: label, color:"#9ca3af" },
      yaxis:{ title: "Count", color:"#9ca3af" },
      paper_bgcolor:"transparent", plot_bgcolor:"transparent", font:{ color:"#d1d5db" },
      margin:{ l:40,r:20,t:20,b:40 }
    };
    Plotly.newPlot("gd-rmse-histogram", [trace], layout);
    document.getElementById("gd-type-plot").style.display="block";
  }

  function initGalaxyTypeCheckboxes(){
    const container=document.getElementById("gd-type-checkboxes");
    container.innerHTML = "";
    distinctTypes.forEach(labelName=>{
      const id = `type_${labelName.replace(/[^a-zA-Z0-9_-]/g,'_')}`;
      const wrap=document.createElement("label");
      wrap.className="flex items-center space-x-2 cursor-pointer bg-gray-700/50 px-3 py-1 rounded border border-gray-600 hover:bg-gray-600 transition";
      wrap.innerHTML = `<input id="${id}" type="checkbox" value="${labelName}" checked class="form-checkbox text-blue-500 rounded bg-gray-800 border-gray-500" /> <span class="text-sm font-medium">${labelName}</span>`;
      container.appendChild(wrap);
    });
  }

  /* INIT */
  document.addEventListener("DOMContentLoaded", ()=>{
    loadData();
    document.getElementById("gd-analyze-types-btn").addEventListener("click", analyzeSelectedTypes);
    document.getElementById("gd-galaxy-select").addEventListener("change", ()=>{ updateGalaxyInfo(); updateAll(); });
    yDiskSlider.addEventListener("input", ()=>{ updateAll(); });
    yBulgeSlider.addEventListener("input", ()=>{ updateAll(); });
    autofitCheck.addEventListener("change", ()=>{ updateAll(); });
  });

} // End Scope
</script>