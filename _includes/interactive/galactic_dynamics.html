<div id="gd-overall-median-inline" class="mt-4 text-cyan-200 font-semibold"></div>

<div id="gd-type-filter" class="bg-gray-800/50 p-4 rounded-lg mb-4">
  <div class="flex flex-wrap justify-between items-end gap-4">
    <div>
      <h4 class="text-lg font-bold text-gray-200 mb-2">Filter by Hubble Type:</h4>
      <div id="gd-type-checkboxes" class="flex flex-wrap gap-4 text-gray-300"></div>
    </div>
    
    <div class="bg-gray-900/50 p-3 rounded border border-gray-600">
      <span class="text-xs font-bold text-gray-400 uppercase tracking-wider block mb-2">Analysis Metric</span>
      <div class="flex space-x-4">
        <label class="flex items-center cursor-pointer">
          <input type="radio" name="analysis-metric" value="rmse" checked class="form-radio text-blue-500">
          <span class="ml-2 text-gray-200">RMSE</span>
        </label>
        <label class="flex items-center cursor-pointer">
          <input type="radio" name="analysis-metric" value="chi2" class="form-radio text-purple-500">
          <span class="ml-2 text-gray-200">Reduced χ²</span>
        </label>
      </div>
    </div>
  </div>
  
  <button id="gd-analyze-types-btn" class="mt-4 px-6 py-2 bg-blue-600 text-white font-bold rounded hover:bg-blue-500 transition w-full md:w-auto">
    Analyze Distribution
  </button>
</div>

<div id="gd-type-plot" class="bg-gray-800/50 p-4 rounded-lg mb-4" style="display:none">
  <div id="gd-overall-median" class="text-gray-200 font-semibold mb-3 text-lg"></div>
  <div id="gd-rmse-histogram"></div>
</div>

<div class="calculator-container bg-gray-800/50 p-6 rounded-lg">
  <div id="gd-loader">Loading SPARC Database...</div>

  <div id="gd-calculator-body" style="display:none">
    <div class="controls-grid">
      <div class="control-group">
        <label for="gd-galaxy-select">Select Galaxy:</label>
        <select id="gd-galaxy-select" class="form-control"></select>
      </div>

      <div class="control-group">
        <div class="flex justify-between items-center mb-2">
          <label for="gd-ystar-slider" class="mb-0">Stellar M/L Ratio (Υ*): 
            <span id="gd-ystar-value" class="param-display">0.66</span>
          </label>
          
          <label class="flex items-center space-x-2 cursor-pointer bg-gray-700 px-3 py-1 rounded border border-gray-600 hover:bg-gray-600 transition">
            <input type="checkbox" id="gd-autofit-check" class="form-checkbox text-blue-500 rounded">
            <span class="text-sm font-bold text-blue-300">Auto-fit (Min RMSE)</span>
          </label>
        </div>
        
        <input type="range" id="gd-ystar-slider" class="form-range" min="0.05" max="3.00" step="0.01" value="0.66" />
      </div>
    </div>

    <div id="gd-galaxy-info" class="bg-gray-800/50 p-4 rounded-lg mb-4"></div>

    <div id="gd-results" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
      <div class="metric-box bg-gray-700/50 border border-gray-600 rounded p-4 text-center">
        <div class="text-gray-400 text-sm uppercase tracking-widest mb-1">RMSE</div>
        <div class="text-3xl font-bold text-white" id="res-rmse">--</div>
        <div class="text-xs text-gray-500 mt-1">km/s</div>
      </div>
      <div class="metric-box bg-gray-700/50 border border-gray-600 rounded p-4 text-center">
        <div class="text-gray-400 text-sm uppercase tracking-widest mb-1">Reduced χ²</div>
        <div class="text-3xl font-bold text-purple-300" id="res-chi">--</div>
        <div class="text-xs text-gray-500 mt-1">Target ~ 1.0</div>
      </div>
    </div>
    
    <div id="gd-warning" class="warning"></div>

    <div class="plot-wrapper">
      <div class="plot-box"><div id="gd-plot-div"></div></div>
      <div class="plot-box"><div id="gd-plot-div-components"></div></div>
    </div>
  </div>
</div>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<style>
  /* Layout Fixes */
  .calculator-container {
    background-color: rgba(31,41,55,0.5);
    border-radius: 15px;
    padding: 30px 40px;
    margin: 20px auto;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    border: 1px solid #374151;
    width: 100%;
    max-width: 1400px;
  }
  
  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 30px;
    margin-bottom: 20px;
  }
  
  .control-group { display: flex; flex-direction: column; }
  .control-group label { font-weight: 600; color: #d1d5db; }
  
  .form-control, .form-range {
    width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #4b5563;
    background-color: #374151; color: #d1d5db; box-sizing: border-box;
  }
  .param-display { font-weight: 700; color: #67e8f9; }
  
  #gd-warning { text-align: center; color: #f87171; font-weight: 700; margin-top: 10px; }
  
  .plot-wrapper {
    display: flex; flex-wrap: wrap; gap: 20px; margin-top: 25px; padding-top: 25px;
    border-top: 1px solid #4b5563; justify-content: center;
  }
  
  .plot-box {
    flex: 1 1 48%; min-width: 400px; height: 550px;
    border-radius: 8px; background: #1f2937; position: relative;
  }
  
  #gd-loader { text-align: center; font-size: 1.5em; padding: 50px; color: #9ca3af; }
</style>

<script>
{ // Block Scope start
  
  /* CONFIG & GLOBALS */
  const RAW_BASE = "https://raw.githubusercontent.com/AntonRize/WILL/main/SPARC%20DATA/";
  const URL_TABLE1 = RAW_BASE + "table1.dat";
  const URL_TABLE2 = RAW_BASE + "table2.dat";

  let galaxyData = {};
  let galaxyMeta = {};
  let distinctTypes = [];
  const defaultValues = { yStar: 0.66 };
  const hubbleTypes = ["S0","Sa","Sab","Sb","Sbc","Sc","Scd","Sd","Sdm","Sm","Im","BCD"];

  // --- PHYSICS CONSTANTS (Derived from H0) ---
  const C_LIGHT_KMS = 299792.458; 
  const H0 = 73.2; // SH0ES 2024
  const MPC_TO_M = 3.086e22; 
  const KPC_TO_M = 3.086e19; 

  const H0_SI = (H0 * 1000) / MPC_TO_M;
  const C_SI = C_LIGHT_KMS * 1000;
  const A_VAC_SI = (C_SI * H0_SI) / (2 * Math.PI); 

  /* DOM Elements */
  const loader = document.getElementById("gd-loader");
  const bodyEl = document.getElementById("gd-calculator-body");
  const galaxySelect = document.getElementById("gd-galaxy-select");
  const ystarSlider = document.getElementById("gd-ystar-slider");
  const ystarValueSpan = document.getElementById("gd-ystar-value");
  const autofitCheck = document.getElementById("gd-autofit-check");
  const resRmse = document.getElementById("res-rmse");
  const resChi = document.getElementById("res-chi");
  const plotDiv = document.getElementById("gd-plot-div");
  const plotDivComponents = document.getElementById("gd-plot-div-components");
  const galaxyInfoDiv = document.getElementById("gd-galaxy-info");

  /* LOAD DATA */
  async function loadData(){
    try{
      if(!window.Plotly) throw new Error("Plotly failed to load.");
      const [t1Res,t2Res]=await Promise.all([fetch(URL_TABLE1),fetch(URL_TABLE2)]);
      if(!t1Res.ok||!t2Res.ok) throw new Error("Failed to fetch SPARC tables.");

      const t1Text=await t1Res.text();
      const t2Text=await t2Res.text();

      // Parse Table 1
      const typeSet = new Set();
      t1Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const name=line.substring(0,11).trim();
        const rest=line.substring(11).trim().split(/\s+/);
        if(rest.length<18) return;
        
        galaxyMeta[name]={
          Name:name,
          Rdisk: +rest[10], 
          Dist:+rest[1], 
          L36:+rest[6],
          TypeRaw:rest[0]
        };
        const typeId = parseInt(rest[0],10);
        const typeLabel = (hubbleTypes[typeId]!==undefined) ? hubbleTypes[typeId] : String(rest[0]);
        galaxyMeta[name].TypeLabel = typeLabel;
        typeSet.add(typeLabel);
      });
      distinctTypes = Array.from(typeSet).sort();

      // Parse Table 2 (NOW CAPTURING ERRORS)
      t2Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const p=line.trim().split(/\s+/);
        if(p.length<8) return;
        // p[4] is Vobs_err
        const row={ 
          Name:p[0], Dist:+p[1], Rad:+p[2], 
          Vobs:+p[3], Verr:+p[4], 
          Vgas:+p[5], Vdisk:+p[6], Vbul:+p[7] 
        };
        (galaxyData[row.Name] ||= []).push(row);
      });

      // Init UI
      Object.keys(galaxyData).sort().forEach(name=>{
        if(galaxyData[name].length<3) return;
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name; galaxySelect.appendChild(opt);
      });
      initGalaxyTypeCheckboxes();
      loader.style.display="none"; bodyEl.style.display="block";
      galaxySelect.selectedIndex=0;
      updateGalaxyInfo();
      updateAll();
    }catch(err){
      loader.textContent = "Error loading data: " + err.message;
      console.error(err);
    }
  }

  /* PHYSICS CORE */
  function seriesQWILL(galaxyName, yStar){
    const data = (galaxyData[galaxyName]||[]).slice().sort((a,b)=>a.Rad-b.Rad);
    const r = [], Vobs = [], Verr = [], Vbary = [], Vq = [];
    const Vgas_comp = [], Vdisk_scaled = [], Vbulge_scaled = [];

    for(const d of data){
      const vo = (Number.isFinite(d.Vobs) && d.Vobs >= 0) ? d.Vobs : NaN;
      if(!Number.isFinite(vo)) continue;

      const vg = d.Vgas > 0 ? d.Vgas : 0;
      const vd = d.Vdisk > 0 ? d.Vdisk : 0;
      const vb = d.Vbul > 0 ? d.Vbul : 0;

      // 1. Baryonic Velocity
      const vbary2 = vg*vg + yStar * (vd*vd + vb*vb);
      const vbary  = Math.sqrt(Math.max(0, vbary2));
      
      // 2. Screening
      let chi = 0;
      if (d.Rad > 0) {
        const g_bar = (vbary * 1000)**2 / (d.Rad * KPC_TO_M);
        chi = g_bar / A_VAC_SI;
      } else {
        chi = 1e6; 
      }
      
      // 3. Prediction
      const factor = Math.sqrt(1 + 2 * Math.exp(-chi));
      const vq = vbary * factor;

      r.push(d.Rad);
      Vobs.push(vo);
      Verr.push(d.Verr > 0 ? d.Verr : 1.0); // Safe floor for errors
      Vbary.push(vbary);
      Vq.push(vq);
      
      Vgas_comp.push(vg);
      Vdisk_scaled.push(Math.sqrt(yStar) * vd);
      Vbulge_scaled.push(Math.sqrt(yStar) * vb);
    }
    return { r, Vobs, Verr, Vbary, Vq, components: { Vgas: Vgas_comp, Vdisk_scaled, Vbulge_scaled } };
  }

  /* OPTIMIZATION LOGIC (Minimizes RMSE) */
  function optimizeYStar(galaxyName) {
    let bestY = 0.66;
    let minErr = Infinity;
    // Minimize RMSE (could optimize for Chi2, but RMSE is standard fit target)
    for(let y = 0.05; y <= 2.5; y += 0.1) {
      const S = seriesQWILL(galaxyName, y);
      const err = calculateRMSE(S.Vobs, S.Vq);
      if(Number.isFinite(err) && err < minErr) { minErr = err; bestY = y; }
    }
    let start = Math.max(0.01, bestY - 0.1);
    let end = bestY + 0.1;
    for(let y = start; y <= end; y += 0.01) {
      const S = seriesQWILL(galaxyName, y);
      const err = calculateRMSE(S.Vobs, S.Vq);
      if(Number.isFinite(err) && err < minErr) { minErr = err; bestY = y; }
    }
    return bestY;
  }

  /* METRICS */
  function calculateRMSE(obs, pred){
    let s=0, k=0;
    for(let i=0;i<Math.min(obs.length,pred.length);i++){
      if(Number.isFinite(obs[i]) && Number.isFinite(pred[i])){ s+=(obs[i]-pred[i])**2; k++; }
    }
    return k>0 ? Math.sqrt(s/k) : NaN;
  }

  function calculateReducedChi2(obs, pred, err, freeParams){
    let s=0, k=0;
    for(let i=0;i<Math.min(obs.length,pred.length);i++){
      if(Number.isFinite(obs[i]) && Number.isFinite(pred[i]) && Number.isFinite(err[i])){ 
        const sigma = err[i] > 0 ? err[i] : 1.0; // avoid div by zero
        s += ((obs[i]-pred[i]) / sigma)**2; 
        k++; 
      }
    }
    // DOF = N - freeParams
    const dof = k - freeParams;
    return dof > 0 ? s/dof : NaN;
  }
  
  function blueRedColor(v, vmin, vmax){
    if(!isFinite(v) || !isFinite(vmin) || !isFinite(vmax) || vmax<=vmin) return "rgb(128,128,128)";
    const t = (v - vmin) / (vmax - vmin);
    const r = 59 + (239-59)*t;
    const g = 130 + (68-130)*t;
    const b = 246 + (68-246)*t;
    return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
  }

  function updateOverallMedianInline(){
    const el = document.getElementById("gd-overall-median-inline");
    el.innerHTML = `<span class="opacity-70">Click "Analyze Distribution" to calculate global stats</span>`;
  }

  function updateAll(){
    const name = galaxySelect.value; if(!name) return;
    const isAuto = autofitCheck.checked;
    
    if (isAuto) {
      ystarSlider.disabled = true;
      ystarSlider.classList.add("opacity-50", "cursor-not-allowed");
    } else {
      ystarSlider.disabled = false;
      ystarSlider.classList.remove("opacity-50", "cursor-not-allowed");
    }

    let yStar = 0.66;
    if (isAuto) {
      yStar = optimizeYStar(name);
      ystarValueSpan.textContent = yStar.toFixed(2) + " (Auto)";
    } else {
      yStar = +ystarSlider.value;
      ystarValueSpan.textContent = yStar.toFixed(2);
    }

    const S = seriesQWILL(name, yStar);
    const R = calculateRMSE(S.Vobs, S.Vq);
    // free params: 1 if auto, 0 if fixed
    const k_param = isAuto ? 1 : 0; 
    const Chi = calculateReducedChi2(S.Vobs, S.Vq, S.Verr, k_param);

    resRmse.textContent = isFinite(R) ? R.toFixed(2) : "—";
    resChi.textContent = isFinite(Chi) ? Chi.toFixed(2) : "—";
    
    // Plotting ...
    const ymax = Math.max(1, ...S.Vobs, ...S.Vq);
    const layoutBase = {
      xaxis:{ title:"r (kpc)", color:"#d1d5db", gridcolor:"#4b5563" },
      yaxis:{ title:"Velocity (km/s)", color:"#d1d5db", gridcolor:"#4b5563", range:[0, ymax*1.1] },
      legend:{ orientation:"h", bgcolor:"rgba(31,41,55,0.9)", font:{color:"#d1d5db"} },
      margin:{ l:60, r:30, b:50, t:60 },
      paper_bgcolor:"transparent", plot_bgcolor:"#1f2937", font:{ color:"#d1d5db" }
    };

    Plotly.react(
      plotDiv,
      [
        { x:S.r, y:S.Vobs, error_y: { type: 'data', array: S.Verr, visible: true, color: '#6b7280' }, mode:"markers", name:"Observed", marker:{ color:"#d1d5db", size:6 }},
        { x:S.r, y:S.Vbary, mode:"lines", name:"Baryonic", line:{ color:"#9ca3af", dash:"dash" }},
        { x:S.r, y:S.Vq,    mode:"lines", name:"WILL Predicted", line:{ color:"#67e8f9", width:4 }}
      ],
      { ...layoutBase, title:`Rotation Curve for ${name}` }
    );

    Plotly.react(
      plotDivComponents,
      [
        { x:S.r, y:S.Vobs,                     mode:"markers", name:"Observed", marker:{ color:"#9ca3af", size:6, symbol:"circle-open" }},
        { x:S.r, y:S.components.Vgas,          mode:"lines",   name:"Gas",       line:{ color:"#10b981" }},
        { x:S.r, y:S.components.Vdisk_scaled,  mode:"lines",   name:"Disk × Υ*", line:{ color:"#3b82f6" }},
        { x:S.r, y:S.components.Vbulge_scaled, mode:"lines",   name:"Bulge × Υ*",line:{ color:"#f59e0b" }}
      ],
      { ...layoutBase, title:`Baryonic Components for ${name}` }
    );
  }

  function updateGalaxyInfo(){
     const meta=galaxyMeta[galaxySelect.value]; if(!meta) return;
     const hubbleLabel = meta.TypeLabel || meta.TypeRaw;
     galaxyInfoDiv.innerHTML = `
       <p><strong>Type:</strong> ${hubbleLabel}</p>
       <p><strong>Distance:</strong> ${meta.Dist} Mpc</p>
       <p><strong>R_disk:</strong> ${meta.Rdisk} kpc</p>
       <p><strong>Luminosity:</strong> ${meta.L36} G L&#9737;</p>
     `;
  }

  /* HISTOGRAM HELPERS */
  function buildHistogramData(values, vInitValues, bins){
    const N = values.length; if(!N) return null;
    const B = bins || 20;
    
    // Filter out huge outliers for histogram scaling
    // For Chi2, values can explode if fit is bad. Cap at sensible visualization limit.
    const safeValues = values.filter(v => Number.isFinite(v) && v < 200); 
    
    const minVal = Math.min(...safeValues);
    const maxVal = Math.max(...safeValues);
    const binWidth = (maxVal - minVal) / B || 1;
    
    const counts = new Array(B).fill(0);
    const sumInit = new Array(B).fill(0);
    
    for(let i=0;i<N;i++){
      if (!Number.isFinite(values[i]) || values[i] > 200) continue; // skip outliers
      let idx = Math.floor((values[i]-minVal)/binWidth);
      if(idx>=B) idx = B-1; if(idx<0) idx=0;
      counts[idx] += 1;
      sumInit[idx] += (Number.isFinite(vInitValues[i]) ? vInitValues[i] : 0);
    }
    const avgInit = counts.map((c,i)=> c>0 ? sumInit[i]/c : 0);
    const minInit = Math.min(...avgInit.filter(x=>isFinite(x)));
    const maxInit = Math.max(...avgInit.filter(x=>isFinite(x)));
    const binCenters = Array.from({length: B}, (_,i)=> minVal + i*binWidth + binWidth/2);
    return {counts, avgInit, minInit, maxInit, binCenters, binWidth};
  }

  function analyzeSelectedTypes(){
    const btn = document.getElementById("gd-analyze-types-btn");
    btn.textContent = "Calculating...";
    btn.disabled = true;

    setTimeout(() => {
      const selected = Array.from(document.querySelectorAll("#gd-type-checkboxes input:checked")).map(cb=>cb.value);
      if(!selected.length){ alert("Select at least one galaxy type first."); btn.textContent="Analyze Distribution"; btn.disabled=false; return; }
      
      const isAuto = autofitCheck.checked;
      const yStarFixed = +ystarSlider.value;
      
      // Check which metric to analyze
      const metricRadio = document.querySelector('input[name="analysis-metric"]:checked');
      const mode = metricRadio ? metricRadio.value : 'rmse'; // 'rmse' or 'chi2'

      const metricValues=[];
      const vInitValues=[];
      
      for(const name in galaxyData){
        const meta=galaxyMeta[name]; if(!meta) continue;
        if(!selected.includes(meta.TypeLabel)) continue;
        
        const yVal = isAuto ? optimizeYStar(name) : yStarFixed;
        const S=seriesQWILL(name, yVal);
        
        if(S.Vobs.length > 0){
          let val = NaN;
          if(mode === 'rmse'){
             val = calculateRMSE(S.Vobs, S.Vq);
          } else {
             const k = isAuto ? 1 : 0;
             val = calculateReducedChi2(S.Vobs, S.Vq, S.Verr, k);
          }
          
          if(Number.isFinite(val)){
            metricValues.push(val);
            vInitValues.push(S.Vobs[0]);
          }
        }
      }
      
      if(!metricValues.length){ alert("No valid data found."); btn.textContent="Analyze Distribution"; btn.disabled=false; return; }
      
      const N = metricValues.length;
      const sorted = metricValues.slice().sort((a,b)=>a-b);
      const mid = Math.floor(N/2);
      const median = (N%2===0) ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];

      const modeText = isAuto ? "(Auto-fitted Υ*)" : `(Fixed Υ*=${yStarFixed.toFixed(2)})`;
      const metricLabel = mode === 'rmse' ? "RMSE" : "Reduced χ²";
      const unit = mode === 'rmse' ? " km/s" : "";
      
      document.getElementById("gd-overall-median").innerHTML = 
        `Metric: <b>${metricLabel}</b> — Types: <b>${selected.join(", ")}</b> — N = ${N} — <b>Median = ${median.toFixed(2)}${unit}</b> <span class="text-blue-300 text-sm ml-2">${modeText}</span>`;

      const H = buildHistogramData(metricValues, vInitValues, 30);
      const colors = H.avgInit.map(v => blueRedColor(v, H.minInit, H.maxInit));
      
      const trace = {
        type: "bar", x: H.binCenters, y: H.counts,
        marker: { color: colors, line: { color: "#111827", width: 1 } },
        width: H.binWidth*0.95
      };
      const layoutHist = {
        xaxis:{ title: metricLabel + (mode==='rmse'?" (km/s)":""), color:"#d1d5db" },
        yaxis:{ title:"Count", color:"#d1d5db" },
        paper_bgcolor:"transparent", plot_bgcolor:"#1f2937", font:{ color:"#d1d5db" },
        margin:{ l:40,r:20,t:20,b:40 }
      };
      Plotly.newPlot("gd-rmse-histogram", [trace], layoutHist);
      document.getElementById("gd-type-plot").style.display="block";
      
      btn.textContent = "Analyze Distribution";
      btn.disabled = false;
    }, 50);
  }

  function initGalaxyTypeCheckboxes(){
    const container=document.getElementById("gd-type-checkboxes");
    container.innerHTML = "";
    distinctTypes.forEach(labelName=>{
      const id = `type_${labelName.replace(/[^a-zA-Z0-9_-]/g,'_')}`;
      const wrap=document.createElement("label");
      wrap.className="flex items-center space-x-2";
      wrap.htmlFor = id;
      wrap.innerHTML = `<input id="${id}" type="checkbox" value="${labelName}" checked /> <span>${labelName}</span>`;
      container.appendChild(wrap);
    });
  }

  /* INIT LISTENERS */
  document.addEventListener("DOMContentLoaded", ()=>{
    loadData();
    document.getElementById("gd-analyze-types-btn").addEventListener("click", analyzeSelectedTypes);
    document.getElementById("gd-galaxy-select").addEventListener("change", ()=>{ updateGalaxyInfo(); updateAll(); });
    document.getElementById("gd-ystar-slider").addEventListener("input", ()=>{ updateAll(); });
    document.getElementById("gd-autofit-check").addEventListener("change", ()=>{ updateAll(); });
  });

} // <--- BLOCK SCOPE END
</script>