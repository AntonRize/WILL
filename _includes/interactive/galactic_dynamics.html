<div id="gd-overall-median-inline" class="mt-4 text-cyan-200 font-semibold"></div>

<div id="gd-type-filter" class="bg-gray-800/50 p-4 rounded-lg mb-4">
  <h4 class="text-lg font-bold text-gray-200 mb-2">Filter by Hubble Type:</h4>
  <div id="gd-type-checkboxes" class="flex flex-wrap gap-4 text-gray-300"></div>
  <button id="gd-analyze-types-btn" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500 transition">Analyze RMSE by Type</button>
</div>

<div id="gd-type-plot" class="bg-gray-800/50 p-4 rounded-lg mb-4" style="display:none">
  <div id="gd-overall-median" class="text-gray-200 font-semibold mb-3"></div>
  <div id="gd-rmse-histogram"></div>
</div>

<div class="calculator-container bg-gray-800/50 p-6 rounded-lg">
  <div id="gd-loader">Loading SPARC Database...</div>

  <div id="gd-calculator-body" style="display:none">
    <div class="controls-grid">
      <div class="control-group">
        <label for="gd-galaxy-select">Select Galaxy:</label>
        <select id="gd-galaxy-select" class="form-control"></select>
      </div>

      <div class="control-group">
        <div class="flex justify-between items-center mb-2">
          <label for="gd-ystar-slider" class="mb-0">Stellar M/L Ratio (Υ*): 
            <span id="gd-ystar-value" class="param-display">0.66</span>
          </label>
          
          <label class="flex items-center space-x-2 cursor-pointer bg-gray-700 px-3 py-1 rounded border border-gray-600 hover:bg-gray-600">
            <input type="checkbox" id="gd-autofit-check" class="form-checkbox text-blue-500 rounded">
            <span class="text-sm font-bold text-blue-300">Auto-fit (Best RMSE)</span>
          </label>
        </div>
        
        <input type="range" id="gd-ystar-slider" class="form-range" min="0.05" max="3.00" step="0.01" value="0.66" />
      </div>
    </div>

    <div id="gd-galaxy-info" class="bg-gray-800/50 p-4 rounded-lg mb-4"></div>

    <div id="gd-results"></div>
    <div id="gd-warning" class="warning"></div>

    <div class="plot-wrapper">
      <div class="plot-box"><div id="gd-plot-div"></div></div>
      <div class="plot-box"><div id="gd-plot-div-components"></div></div>
    </div>
  </div>
</div>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<style>
  /* Fixed Width Issue: Increased max-width and ensured 100% width */
  .calculator-container {
    background-color: rgba(31,41,55,0.5);
    border-radius: 15px;
    padding: 30px 40px;
    margin: 20px auto;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    border: 1px solid #374151;
    width: 100%;
    max-width: 1400px; /* Made wider */
  }
  
  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 30px;
    margin-bottom: 20px;
  }
  
  .control-group { display: flex; flex-direction: column; }
  .control-group label { font-weight: 600; color: #d1d5db; }
  
  .form-control, .form-range {
    width: 100%;
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #4b5563;
    background-color: #374151;
    color: #d1d5db;
    box-sizing: border-box;
  }
  
  .param-display { font-weight: 700; color: #67e8f9; }
  
  #gd-results {
    text-align: center;
    font-size: 1.4em;
    font-weight: 700;
    margin: 20px 0 25px;
    color: #d1d5db;
    padding: 15px;
    background: #374151;
    border-radius: 8px;
    border: 1px solid #4b5563;
  }
  
  #gd-warning { text-align: center; color: #f87171; font-weight: 700; margin-top: 10px; }
  
  .plot-wrapper {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 25px;
    padding-top: 25px;
    border-top: 1px solid #4b5563;
    justify-content: center;
  }
  
  /* Make plots fill the wider container */
  .plot-box {
    flex: 1 1 48%;
    min-width: 400px;
    height: 550px;
    border-radius: 8px;
    background: #1f2937;
    position: relative;
  }
  
  #gd-loader { text-align: center; font-size: 1.5em; padding: 50px; color: #9ca3af; }
</style>

<script>
{ // Block Scope start
  
  /* CONFIG & GLOBALS */
  const RAW_BASE = "https://raw.githubusercontent.com/AntonRize/WILL/main/SPARC%20DATA/";
  const URL_TABLE1 = RAW_BASE + "table1.dat";
  const URL_TABLE2 = RAW_BASE + "table2.dat";

  let galaxyData = {};
  let galaxyMeta = {};
  let distinctTypes = [];
  const defaultValues = { yStar: 0.66 };
  const hubbleTypes = ["S0","Sa","Sab","Sb","Sbc","Sc","Scd","Sd","Sdm","Sm","Im","BCD"];

  // --- PHYSICS CONSTANTS (Derived from H0) ---
  const C_LIGHT_KMS = 299792.458; 
  const H0 = 73.2; // Hubble Constant (SH0ES 2024 best fit)
  const MPC_TO_M = 3.086e22; 
  const KPC_TO_M = 3.086e19; 

  // a_vac = c * H0 / 2pi
  const H0_SI = (H0 * 1000) / MPC_TO_M;
  const C_SI = C_LIGHT_KMS * 1000;
  const A_VAC_SI = (C_SI * H0_SI) / (2 * Math.PI); 

  /* DOM Elements */
  const loader = document.getElementById("gd-loader");
  const bodyEl = document.getElementById("gd-calculator-body");
  const galaxySelect = document.getElementById("gd-galaxy-select");
  const ystarSlider = document.getElementById("gd-ystar-slider");
  const ystarValueSpan = document.getElementById("gd-ystar-value");
  const autofitCheck = document.getElementById("gd-autofit-check");
  const resultsDiv = document.getElementById("gd-results");
  const plotDiv = document.getElementById("gd-plot-div");
  const plotDivComponents = document.getElementById("gd-plot-div-components");
  const galaxyInfoDiv = document.getElementById("gd-galaxy-info");

  /* LOAD DATA */
  async function loadData(){
    try{
      if(!window.Plotly) throw new Error("Plotly failed to load.");
      const [t1Res,t2Res]=await Promise.all([fetch(URL_TABLE1),fetch(URL_TABLE2)]);
      if(!t1Res.ok||!t2Res.ok) throw new Error("Failed to fetch SPARC tables.");

      const t1Text=await t1Res.text();
      const t2Text=await t2Res.text();

      // Parse Table 1
      const typeSet = new Set();
      t1Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const name=line.substring(0,11).trim();
        const rest=line.substring(11).trim().split(/\s+/);
        if(rest.length<18) return;
        
        galaxyMeta[name]={
          Name:name,
          Rdisk: +rest[10], 
          Dist:+rest[1], 
          L36:+rest[6],
          TypeRaw:rest[0]
        };
        const typeId = parseInt(rest[0],10);
        const typeLabel = (hubbleTypes[typeId]!==undefined) ? hubbleTypes[typeId] : String(rest[0]);
        galaxyMeta[name].TypeLabel = typeLabel;
        typeSet.add(typeLabel);
      });
      distinctTypes = Array.from(typeSet).sort();

      // Parse Table 2
      t2Text.trim().split("\n").forEach(line=>{
        if(line.startsWith("#")) return;
        const p=line.trim().split(/\s+/);
        if(p.length<8) return;
        const row={ Name:p[0], Dist:+p[1], Rad:+p[2], Vobs:+p[3], Vobs_err:+p[4], Vgas:+p[5], Vdisk:+p[6], Vbul:+p[7] };
        (galaxyData[row.Name] ||= []).push(row);
      });

      // Init UI
      Object.keys(galaxyData).sort().forEach(name=>{
        if(galaxyData[name].length<3) return;
        const opt=document.createElement("option");
        opt.value=name; opt.textContent=name; galaxySelect.appendChild(opt);
      });
      initGalaxyTypeCheckboxes();
      loader.style.display="none"; bodyEl.style.display="block";
      galaxySelect.selectedIndex=0;
      updateGalaxyInfo();
      updateAll();
    }catch(err){
      loader.textContent = "Error loading data: " + err.message;
      console.error(err);
    }
  }

  /* PHYSICS CORE: ACCELERATION SCREENING */
  function seriesQWILL(galaxyName, yStar){
    const data = (galaxyData[galaxyName]||[]).slice().sort((a,b)=>a.Rad-b.Rad);
    const r = [], Vobs = [], Vbary = [], Vq = [];
    const Vgas_comp = [], Vdisk_scaled = [], Vbulge_scaled = [];

    for(const d of data){
      const vo = (Number.isFinite(d.Vobs) && d.Vobs >= 0) ? d.Vobs : NaN;
      if(!Number.isFinite(vo)) continue;

      const vg = d.Vgas > 0 ? d.Vgas : 0;
      const vd = d.Vdisk > 0 ? d.Vdisk : 0;
      const vb = d.Vbul > 0 ? d.Vbul : 0;

      // 1. Baryonic Velocity (Matter Component)
      const vbary2 = vg*vg + yStar * (vd*vd + vb*vb);
      const vbary  = Math.sqrt(Math.max(0, vbary2));
      
      // 2. Screening Factor (Physics based)
      // chi = g_bary / a_vac
      let chi = 0;
      if (d.Rad > 0) {
        const g_bar = (vbary * 1000)**2 / (d.Rad * KPC_TO_M);
        chi = g_bar / A_VAC_SI;
      } else {
        chi = 1e6; 
      }
      
      // 3. Universal Interpolation
      const factor = Math.sqrt(1 + 2 * Math.exp(-chi));
      const vq = vbary * factor;

      r.push(d.Rad);
      Vobs.push(vo);
      Vbary.push(vbary);
      Vq.push(vq);
      
      Vgas_comp.push(vg);
      Vdisk_scaled.push(Math.sqrt(yStar) * vd);
      Vbulge_scaled.push(Math.sqrt(yStar) * vb);
    }
    return { r, Vobs, Vbary, Vq, components: { Vgas: Vgas_comp, Vdisk_scaled, Vbulge_scaled } };
  }

  /* OPTIMIZATION LOGIC */
  function optimizeYStar(galaxyName) {
    let bestY = 0.66;
    let minRMSE = Infinity;
    
    // Coarse search
    for(let y = 0.05; y <= 2.5; y += 0.1) {
      const S = seriesQWILL(galaxyName, y);
      const err = rmse(S.Vobs, S.Vq);
      if(Number.isFinite(err) && err < minRMSE) { minRMSE = err; bestY = y; }
    }
    // Fine search
    let start = Math.max(0.01, bestY - 0.1);
    let end = bestY + 0.1;
    for(let y = start; y <= end; y += 0.01) {
      const S = seriesQWILL(galaxyName, y);
      const err = rmse(S.Vobs, S.Vq);
      if(Number.isFinite(err) && err < minRMSE) { minRMSE = err; bestY = y; }
    }
    return bestY;
  }

  /* UTILS */
  function rmse(obs, pred){
    let s=0, k=0;
    for(let i=0;i<Math.min(obs.length,pred.length);i++){
      if(Number.isFinite(obs[i]) && Number.isFinite(pred[i])){ s+=(obs[i]-pred[i])**2; k++; }
    }
    return k>0 ? Math.sqrt(s/k) : NaN;
  }
  
  function blueRedColor(v, vmin, vmax){
    if(!isFinite(v) || !isFinite(vmin) || !isFinite(vmax) || vmax<=vmin) return "rgb(128,128,128)";
    const t = (v - vmin) / (vmax - vmin);
    const r = 59 + (239-59)*t;
    const g = 130 + (68-130)*t;
    const b = 246 + (68-246)*t;
    return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
  }

  function computeOverallMedianRMSE(yStarFixed, isAuto){
    const values=[];
    for(const name in galaxyData){
      // If auto is on, calculate optimal Y for this galaxy
      const yVal = isAuto ? optimizeYStar(name) : yStarFixed;
      const S = seriesQWILL(name, yVal);
      if(S.Vobs.length===S.Vq.length && S.Vobs.length>0) values.push(rmse(S.Vobs,S.Vq));
    }
    if(!values.length) return NaN;
    const sorted=values.slice().sort((a,b)=>a-b);
    const mid=Math.floor(sorted.length/2);
    return (sorted.length%2===0) ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];
  }

  function updateOverallMedianInline(){
    const isAuto = autofitCheck.checked;
    const yStar = +ystarSlider.value;
    // Note: Calculating median for 175 galaxies with optimization might take a second.
    // We will display a placeholder if needed, but modern JS is fast enough for 175 items.
    
    // To avoid UI freezing on every slider move, we might only show this when requested, 
    // or just calculate it. For now, let's keep it live but maybe optimized.
    // Actually, let's just show the current single galaxy status in the main view,
    // and only do the heavy global calc when "Analyze" is clicked or page loads.
    // For inline text:
    const el = document.getElementById("gd-overall-median-inline");
    el.innerHTML = `<span class="opacity-70">Click "Analyze RMSE" to see global stats</span>`;
  }

  function updateAll(){
    const name = galaxySelect.value; if(!name) return;
    const isAuto = autofitCheck.checked;
    
    // Slider state logic
    if (isAuto) {
      ystarSlider.disabled = true;
      ystarSlider.classList.add("opacity-50", "cursor-not-allowed");
    } else {
      ystarSlider.disabled = false;
      ystarSlider.classList.remove("opacity-50", "cursor-not-allowed");
    }

    // Determine Y* to use
    let yStar = 0.66;
    if (isAuto) {
      yStar = optimizeYStar(name);
      // Update display text but not the slider handle to avoid confusion jumping
      ystarValueSpan.textContent = yStar.toFixed(2) + " (Auto)";
    } else {
      yStar = +ystarSlider.value;
      ystarValueSpan.textContent = yStar.toFixed(2);
    }

    const S = seriesQWILL(name, yStar);
    const R = rmse(S.Vobs, S.Vq);
    resultsDiv.innerHTML = `RMSE: <span class="text-white">${isFinite(R)?R.toFixed(2):"—"}</span> km/s <span class="text-sm opacity-60 ml-4">(Υ* = ${yStar.toFixed(2)})</span>`;
    
    // Removed the heavy global calculation from here to prevent lag
    // updateOverallMedianInline(); 

    const ymax = Math.max(1, ...S.Vobs, ...S.Vq);
    const layoutBase = {
      xaxis:{ title:"r (kpc)", color:"#d1d5db", gridcolor:"#4b5563" },
      yaxis:{ title:"Velocity (km/s)", color:"#d1d5db", gridcolor:"#4b5563", range:[0, ymax*1.1] },
      legend:{ orientation:"h", bgcolor:"rgba(31,41,55,0.9)", font:{color:"#d1d5db"} },
      margin:{ l:60, r:30, b:50, t:60 },
      paper_bgcolor:"transparent", plot_bgcolor:"#1f2937", font:{ color:"#d1d5db" }
    };

    Plotly.react(
      plotDiv,
      [
        { x:S.r, y:S.Vobs, mode:"markers", name:"Observed", marker:{ color:"#d1d5db", size:8 }},
        { x:S.r, y:S.Vbary, mode:"lines", name:"Baryonic", line:{ color:"#9ca3af", dash:"dash" }},
        { x:S.r, y:S.Vq,    mode:"lines", name:"WILL Predicted", line:{ color:"#67e8f9", width:4 }}
      ],
      { ...layoutBase, title:`Rotation Curve for ${name}` }
    );

    Plotly.react(
      plotDivComponents,
      [
        { x:S.r, y:S.Vobs,                     mode:"markers", name:"Observed", marker:{ color:"#9ca3af", size:6, symbol:"circle-open" }},
        { x:S.r, y:S.components.Vgas,          mode:"lines",   name:"Gas",       line:{ color:"#10b981" }},
        { x:S.r, y:S.components.Vdisk_scaled,  mode:"lines",   name:"Disk × Υ*", line:{ color:"#3b82f6" }},
        { x:S.r, y:S.components.Vbulge_scaled, mode:"lines",   name:"Bulge × Υ*",line:{ color:"#f59e0b" }}
      ],
      { ...layoutBase, title:`Baryonic Components for ${name}` }
    );
  }

  function updateGalaxyInfo(){
     const meta=galaxyMeta[galaxySelect.value]; if(!meta) return;
     const hubbleLabel = meta.TypeLabel || meta.TypeRaw;
     galaxyInfoDiv.innerHTML = `
       <p><strong>Type:</strong> ${hubbleLabel}</p>
       <p><strong>Distance:</strong> ${meta.Dist} Mpc</p>
       <p><strong>R_disk:</strong> ${meta.Rdisk} kpc</p>
       <p><strong>Luminosity:</strong> ${meta.L36} G L&#9737;</p>
     `;
  }

  function buildHistogramData(rmseValues, vInitValues, bins){
    const N = rmseValues.length; if(!N) return null;
    const B = bins || 20;
    const minRMSE = Math.min(...rmseValues);
    const maxRMSE = Math.max(...rmseValues);
    const binWidth = (maxRMSE - minRMSE) / B || 1;
    const counts = new Array(B).fill(0);
    const sumInit = new Array(B).fill(0);
    for(let i=0;i<N;i++){
      let idx = Math.floor((rmseValues[i]-minRMSE)/binWidth);
      if(idx>=B) idx = B-1; if(idx<0) idx=0;
      counts[idx] += 1;
      sumInit[idx] += (Number.isFinite(vInitValues[i]) ? vInitValues[i] : 0);
    }
    const avgInit = counts.map((c,i)=> c>0 ? sumInit[i]/c : 0);
    const minInit = Math.min(...avgInit.filter(x=>isFinite(x)));
    const maxInit = Math.max(...avgInit.filter(x=>isFinite(x)));
    const binCenters = Array.from({length: B}, (_,i)=> minRMSE + i*binWidth + binWidth/2);
    return {counts, avgInit, minInit, maxInit, binCenters, binWidth};
  }

  function analyzeSelectedTypes(){
    const btn = document.getElementById("gd-analyze-types-btn");
    btn.textContent = "Calculating...";
    btn.disabled = true;

    // Use setTimeout to allow UI to render "Calculating"
    setTimeout(() => {
      const selected = Array.from(document.querySelectorAll("#gd-type-checkboxes input:checked")).map(cb=>cb.value);
      if(!selected.length){ alert("Select at least one galaxy type first."); btn.textContent="Analyze RMSE by Type"; btn.disabled=false; return; }
      
      const isAuto = autofitCheck.checked;
      const yStarFixed = +ystarSlider.value;
      const rmseValues=[];
      const vInitValues=[];
      
      for(const name in galaxyData){
        const meta=galaxyMeta[name]; if(!meta) continue;
        if(!selected.includes(meta.TypeLabel)) continue;
        
        // Key Logic: use optimized Y if auto is checked, else slider
        const yVal = isAuto ? optimizeYStar(name) : yStarFixed;
        
        const S=seriesQWILL(name, yVal);
        if(S.Vobs.length===S.Vq.length && S.Vobs.length>0){
          rmseValues.push(rmse(S.Vobs,S.Vq));
          vInitValues.push(S.Vobs[0]);
        }
      }
      
      if(!rmseValues.length){ alert("No galaxies matched."); btn.textContent="Analyze RMSE by Type"; btn.disabled=false; return; }
      
      const N = rmseValues.length;
      const sorted = rmseValues.slice().sort((a,b)=>a-b);
      const mid = Math.floor(N/2);
      const median = (N%2===0) ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];

      const modeText = isAuto ? "(Auto-fitted Υ*)" : `(Fixed Υ*=${yStarFixed.toFixed(2)})`;
      document.getElementById("gd-overall-median").innerHTML = `Types: <b>${selected.join(", ")}</b> — N = ${N} — <b>Median RMSE = ${median.toFixed(2)} km/s</b> <span class="text-blue-300 text-sm ml-2">${modeText}</span>`;

      const H = buildHistogramData(rmseValues, vInitValues, 20);
      const colors = H.avgInit.map(v => blueRedColor(v, H.minInit, H.maxInit));
      const trace = {
        type: "bar", x: H.binCenters, y: H.counts,
        marker: { color: colors, line: { color: "#111827", width: 1 } },
        width: H.binWidth*0.95
      };
      const layoutHist = {
        xaxis:{ title:"RMSE (km/s)", color:"#d1d5db" },
        yaxis:{ title:"Count", color:"#d1d5db" },
        paper_bgcolor:"transparent", plot_bgcolor:"#1f2937", font:{ color:"#d1d5db" },
        margin:{ l:40,r:20,t:20,b:40 }
      };
      Plotly.newPlot("gd-rmse-histogram", [trace], layoutHist);
      document.getElementById("gd-type-plot").style.display="block";
      
      btn.textContent = "Analyze RMSE by Type";
      btn.disabled = false;
    }, 50);
  }

  function initGalaxyTypeCheckboxes(){
    const container=document.getElementById("gd-type-checkboxes");
    container.innerHTML = "";
    distinctTypes.forEach(labelName=>{
      const id = `type_${labelName.replace(/[^a-zA-Z0-9_-]/g,'_')}`;
      const wrap=document.createElement("label");
      wrap.className="flex items-center space-x-2";
      wrap.htmlFor = id;
      wrap.innerHTML = `<input id="${id}" type="checkbox" value="${labelName}" checked /> <span>${labelName}</span>`;
      container.appendChild(wrap);
    });
  }

  /* INIT LISTENERS */
  document.addEventListener("DOMContentLoaded", ()=>{
    loadData();
    document.getElementById("gd-analyze-types-btn").addEventListener("click", analyzeSelectedTypes);
    document.getElementById("gd-galaxy-select").addEventListener("change", ()=>{ updateGalaxyInfo(); updateAll(); });
    document.getElementById("gd-ystar-slider").addEventListener("input", ()=>{ updateAll(); });
    document.getElementById("gd-autofit-check").addEventListener("change", ()=>{ updateAll(); });
  });

} // <--- BLOCK SCOPE END
</script>