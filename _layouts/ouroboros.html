<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M4YFFSYJGF"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-M4YFFSYJGF');
  </script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{% if page.title %}{{ page.title }} | {% endif %}{{ site.title }}</title>

  <meta name="description" content="WILL Relational Geometry - model on fundamental theoretical physics developed by Anton Rize. 
        It builds on principles of rationalism, ontological minimalism and epistemic purity.
        WILL theory deriving from first principals Special Relativity, General Relativity, Cosmology and Quantum Mechanics without any postulates or free parameters. 
        No postulates, no free parameters, no metric.
       With it's extreme methodological constraints offering solutions for long standing problems:
        - Black holes singularity's solution
        - Local energy density in GR  solution
        - Quantum Gravity solution
        - Quantization of spacetime solution
        - Problem of Time solution
        - Cosmological constant solution
        - Dark Energy solution
        - Dark matter solution
        - Galactic rotation curves solution
        - Equation of state w=-1 solution
        - Measurement problem solution
        - Wave function collapse solution
        - Decoherence problem solution
        - Black Hole information loss solution
        - and many more...">

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #111827;
      color: #E5E7EB;
    }
    #ob-tooltip {
      position: absolute;
      z-index: 10;
      max-width: 280px;
      background: rgba(17, 24, 39, 0.85); /* bg-gray-900 */
      backdrop-filter: blur(4px);
      padding: 10px 14px;
      border: 1px solid rgba(55, 65, 81, 0.5); /* border-gray-700 */
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      line-height: 1.5;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-in-out;
      text-align: left;
      white-space: pre-line; /* Allows \n to create new lines */
    }
    #ouroboros-container svg {
        width: 80vw;
        max-width: 800px;
        height: auto;
        opacity: 0; /* Изначально SVG невидим */
        transition: opacity 2.5s ease-in-out; /* Увеличил время для плавности */
    }
  </style>
</head>

<body class="antialiased">
  {% include header.html %}

  <main class="flex flex-col items-center relative p-4 py-20">
    <div id="ouroboros-container" aria-live="polite"></div>
    <div id="ob-tooltip"></div>
    <nav class="mt-10 flex flex-wrap justify-center gap-x-6 gap-y-3 text-sm text-gray-400">
       <a href="{{ site.baseurl }}/relativistic-foundations/" class="hover:text-white transition-colors">Relativistic Foundations</a>
       <a href="{{ site.baseurl }}/results/" class="hover:text-white transition-colors">Results</a>
       <a href="{{ site.baseurl }}/predictions/" class="hover:text-white transition-colors">Predictions</a>
       <a href="{{ site.baseurl }}/WILL-AI/" class="hover:text-white transition-colors">WILL AI</a>
       <a href="{{ site.baseurl }}/about/" class="hover:text-white transition-colors">About</a>
    </nav>
  </main>

  {% include footer.html %}

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('ouroboros-container');
    const tooltip = document.getElementById('ob-tooltip');
    const svgUrl = '{{ site.baseurl }}/assets/OuroborosCLEAN.svg';
    
    const SEGMENT_IDS = ['path34', 'path38', 'path42', 'path46', 'path50'];
    const TOOLTIP_TEXT = {
      'path34': 'SPACETIME ≡ ENERGY\nUnifying Principle removing unjustified separation between “geometry” and “dynamics”.',
      'path38': 'Circle and Sphere\nA closed, isotropic systems with no external reference frame.',
      'path42': 'Universal Rate of Change\nThe speed of light (c) is distributed between kinetic (β) and potential (k) components.',
      'path46': 'Topological Ratio κ²/β² = 2\nThe universal “budget” principle dictating the distribution.',
      'path50': 'Unified Field Equation\nRₛ/r = ρ/ρₘₐₓ\nSPACETIME RATIO = ENERGY RATIO\nLinking back to the Unifying Principle.'
    };
    const targetURL = '{{ site.baseurl }}/relativistic-foundations/';

    fetch(svgUrl)
      .then(response => {
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        return response.text();
      })
      .then(svgText => {
        container.innerHTML = svgText;
        const svg = container.querySelector('svg');
        if (!svg) {
          console.error("Critical Error: SVG element not found after injection.");
          return;
        }
        
        // ИСПОЛЬЗУЕМ requestAnimationFrame ЧТОБЫ ДОЖДАТЬСЯ ОТРИСОВКИ
        requestAnimationFrame(() => {
          // Показываем SVG с плавным fade-in
          svg.style.opacity = '1';
          
          // Запускаем всю логику анимации ПОСЛЕ того, как SVG стал видим
          initializeAnimations(svg);
        });
      })
      .catch(error => {
        console.error('Failed to fetch and load SVG:', error);
        container.innerHTML = `<p class="text-red-500">Error: Could not load the Ouroboros SVG.</p>`;
      });

    function initializeAnimations(svg) {
      console.log("Initializing animations...");
      const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg','defs'), svg.firstChild);
      const glowFilter = document.createElementNS('http://www.w3.org/2000/svg','filter');
      glowFilter.setAttribute('id','innerGlow');
      glowFilter.innerHTML = `
        <feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>
        <feComposite in="SourceGraphic" in2="blur" operator="out" result="cutout"/>
        <feFlood flood-color="rgba(167, 243, 208, 0.7)" result="glow-color"/>
        <feComposite in="glow-color" in2="cutout" operator="in" result="glow-effect"/>
        <feMerge>
            <feMergeNode in="glow-effect"/>
            <feMergeNode in="SourceGraphic"/>
        </feMerge>`;
      defs.appendChild(glowFilter);
      
      const segments = SEGMENT_IDS.map(id => svg.querySelector(`#${id}`)).filter(Boolean);
      
      if (segments.length !== SEGMENT_IDS.length) {
          console.error("Failed to find all SVG segments. Check IDs. Found:", segments.map(s => s.id));
          return;
      }
      console.log("All segments found successfully.");

      const initialHighlightDelay = 1500;
      const highlightDuration = 150;
      const stepDelay = 200;
      segments.forEach((seg, i) => {
        setTimeout(() => {
          seg.style.filter = 'url(#innerGlow)';
          setTimeout(() => { seg.style.filter = 'none'; }, highlightDuration);
        }, initialHighlightDelay + i * stepDelay);
      });

      const breathingDelay = initialHighlightDelay + segments.length * stepDelay;
      setTimeout(() => {
        segments.forEach((seg) => {
          seg.animate([
              { filter: 'none' }, { filter: 'url(#innerGlow)' }, { filter: 'none' }
            ], {
              duration: 5000, iterations: Infinity, easing: 'ease-in-out', delay: Math.random() * 2000 
            });
        });
      }, breathingDelay);
      
      segments.forEach(seg => {
        seg.style.cursor = 'pointer';
        seg.style.transition = 'filter 300ms ease';
        seg.addEventListener('mouseenter', (e) => {
          seg.style.filter = 'url(#innerGlow)';
          tooltip.textContent = TOOLTIP_TEXT[seg.id] || 'Информация не найдена.';
          tooltip.style.opacity = '1';
        });
        seg.addEventListener('mousemove', (e) => {
          tooltip.style.left = (e.clientX + 20) + 'px';
          tooltip.style.top  = (e.clientY - tooltip.offsetHeight - 10) + 'px';
        });
        seg.addEventListener('mouseleave', () => {
          seg.style.filter = 'none';
          tooltip.style.opacity = '0';
        });
        seg.addEventListener('click', () => window.location.href = targetURL);
      });
      console.log("Event listeners attached.");
    }
  });
  </script>
</body>
</html>